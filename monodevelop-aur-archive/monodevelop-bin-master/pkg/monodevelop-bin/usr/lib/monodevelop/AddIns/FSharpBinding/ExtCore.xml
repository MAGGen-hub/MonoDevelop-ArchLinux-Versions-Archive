<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>ExtCore</name></assembly>
<members>
<member name="T:ExtCore.bool`1">
 <summary>
 The type of boolean values, annotated with a unit of measure. The unit of measure is erased in compiled code and when values
 of this type are analyzed using reflection. The type is representationally equivalent to <c>System.Boolean</c>.
 </summary>
</member>
<member name="T:ExtCore.string`1">
 <summary>
 The type of strings, annotated with a unit of measure. The unit of measure is erased in compiled code and when values
 of this type are analyzed using reflection. The type is representationally equivalent to <c>System.String</c>.
 </summary>
</member>
<member name="T:ExtCore.ArrayView`1">
 <summary>
 Array views are similar to array slices, but instead of creating a copy of the
 'sliced' elements they simply provide convienient access to some section of the
 underlying array.
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>
 Type abbreviation for System.ArraySegment&lt;T&gt;
 </remarks>
</member>
<member name="T:ExtCore.Protected`1">
 <summary>A value whose computation has been 'protected' by capturing any raised exception.</summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.dict`2">
 <summary>Represents a generic collection of key/value pairs.</summary>
 <typeparam name="Key"></typeparam>
 <typeparam name="Value"></typeparam>
</member>
<member name="T:ExtCore.nullable`1">
 <summary>
 Represents an object whose underlying type is a value type that can also be assigned null like a reference type.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:ExtCore.Substring.Length">
<summary>
 The number of characters spanned by the substring.
</summary>
</member>
<member name="F:ExtCore.Substring.Offset">
<summary>
 The position of the first character in the substring, relative to the start of the underlying string.
</summary>
</member>
<member name="F:ExtCore.Substring.String">
<summary>
 The underlying string for this substring.
</summary>
</member>
<member name="P:ExtCore.Substring.Item(System.Int32)">
<summary>
 Gets the character at the specified index in the substring.
</summary>
</member>
<member name="P:ExtCore.Substring.IsEmpty">
<summary>
 Is this an empty substring?
</summary>
</member>
<member name="M:ExtCore.Substring.ToString">
 <inherit />
</member>
<member name="M:ExtCore.Substring.ToCharArray">
 <summary>Copies the characters in this substring into a Unicode character array.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.StartsWith(System.String)">
 <summary>Determines whether the beginning of this substring value matches the specified string.</summary>
 <param name="value">The string to compare.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.StartsWith(ExtCore.Substring)">
 <summary>Determines whether the beginning of this substring value matches the specified substring.</summary>
 <param name="value">The substring to compare.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.LastIndexOf(System.Char,System.Int32)">
 <summary>
 Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.
 The search starts at a specified character position and proceeds backward toward the beginning of the substring.
 </summary>
 <param name="value">The Unicode character to seek.</param>
 <param name="startIndex">
 The starting position of the search. The search proceeds from <paramref name="startIndex"/> toward the beginning of this instance.
 </param>
 <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
</member>
<member name="M:ExtCore.Substring.LastIndexOf(System.Char)">
 <summary>
 Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.
 </summary>
 <param name="value">The Unicode character to seek.</param>
 <returns>
 The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not found
 or if the current instance is an empty substring.
 </returns>
</member>
<member name="M:ExtCore.Substring.IndexOf(System.Char,System.Int32)">
 <summary>
 Reports the zero-based index of the first occurrence of the specified Unicode character in this substring.
 The search starts at a specified character position.
 </summary>
 <param name="value">A Unicode character to seek.</param>
 <param name="startIndex">The search starting position.</param>
 <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
</member>
<member name="M:ExtCore.Substring.IndexOf(System.Char)">
 <summary>
 Reports the zero-based index of the first occurrence of the specified Unicode character in this substring.
 </summary>
 <param name="value">A Unicode character to seek.</param>
 <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
</member>
<member name="M:ExtCore.Substring.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Implements F# slicing syntax for substrings.</summary>
 <param name="startIndex"></param>
 <param name="endIndex"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Substring.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Substring.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Substring.System-IEquatable`1-Equals(ExtCore.Substring)">
 <inherit />
</member>
<member name="M:ExtCore.Substring.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Substring.EndsWith(System.String)">
 <summary>Determines whether the end of this substring value matches the specified string.</summary>
 <param name="value">The string to compare.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.EndsWith(ExtCore.Substring)">
 <summary>Determines whether the end of this substring value matches the specified substring.</summary>
 <param name="value">The substring to compare.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.Contains(System.String)">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.Contains(ExtCore.Substring)">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Substring.System-IComparable`1-CompareTo(ExtCore.Substring)">
 <inherit />
</member>
<member name="M:ExtCore.Substring.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Substring.CompareOrdinal(ExtCore.Substring,ExtCore.Substring)">
 <summary>
 Compares two specified <see cref="substring"/> objects by evaluating the numeric values of the corresponding
 <see cref="Char"/> objects in each substring.
 </summary>
 <param name="strA">The first string to compare.</param>
 <param name="strB">The second string to compare.</param>
 <returns>An integer that indicates the lexical relationship between the two comparands.</returns>
</member>
<member name="M:ExtCore.Substring.#ctor(System.String,System.Int32,System.Int32)">
 <summary>Create a new substring value from a specified string.</summary>
 <param name="string"></param>
 <param name="offset"></param>
 <param name="length"></param>
</member>
<member name="M:ExtCore.Substring.#ctor(System.String)">
 <summary>Create a new substring value spanning the entirety of a specified string.</summary>
 <param name="string">The string to use as the substring's underlying string.</param>
</member>
<member name="T:ExtCore.Substring">
<summary>
 Represents a segment of a string.
</summary>
</member>
<member name="F:ExtCore.FSharpVector`1.empty">
<summary>
 The empty vector instance.
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.Null">
<summary>
 The value representing the equivalent of &apos;null&apos; for a vector.
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.LongLength">
<summary>
 Gets a 64-bit integer that represents the total number of elements in the Vector.
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.Length">
<summary>
 Gets a 32-bit integer that represents the total number of elements in the Vector.
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.Item(System.Int32)">
<summary>
 Returns the vector element at the specified index.
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.IsNull">
<summary>
 Is the vector &apos;null&apos; (uninitialized)?
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.IsEmpty">
<summary>
 Is the vector empty?
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.Empty">
<summary>
 The empty vector.
</summary>
</member>
<member name="P:ExtCore.FSharpVector`1.Elements">
<summary>
 Gets the array containing the vector&apos;s elements.
</summary>
</member>
<member name="M:ExtCore.FSharpVector`1.UnsafeCreate(`0[])">
<summary>
 Creates a new Vector from the given array.
 This method is considered &quot;unsafe&quot; and should be used with caution because
 the given array is used directly instead of being copied; if the array is
 modified by some other code, the vector will also be modified (which violates
 the semantics of the type).
</summary>
</member>
<member name="M:ExtCore.FSharpVector`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.FSharpVector`1.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.FSharpVector`1.Create(`0[])">
<summary>
 Creates a new Vector from the given array.
</summary>
</member>
<member name="T:ExtCore.FSharpVector`1">
 <summary>Immutable array with constant-time access to elements.</summary>
</member>
<member name="M:ExtCore.PrintfModule.PrintFormatLineToTraceListeners``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>Print formatted string to Trace listeners, adding a newline.</summary>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.PrintfModule.PrintFormatToTraceListeners``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>Print formatted string to Trace listeners.</summary>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.PrintfModule.PrintFormatToDebugListeners``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>Print formatted string to Debug listeners.</summary>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.PrintfModule.PrintFormatLineToDebugListeners``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
 <summary>Print formatted string to Debug listeners, adding a newline.</summary>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.PrintfModule.PrintFormatLineToStringBuilder``1(System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a System.Text.StringBuilder, adding a newline.</summary>
 <param name="builder"></param>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.PrintfModule">
<summary>
 Extensible printf-style formatting for numbers and other datatypes.
</summary>
</member>
<member name="M:ExtCore.ChoiceModule.ComposeBack``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpChoice{``0,``2}})">
 <summary>
 Composes two functions designed for use with the 'choice' workflow.
 This function is analagous to the F# (&lt;&lt;) operator.
 </summary>
 <param name="f"></param>
 <param name="g"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Compose``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}})">
 <summary>
 Composes two functions designed for use with the 'choice' workflow.
 This function is analagous to the F# (&gt;&gt;) operator.
 </summary>
 <param name="f"></param>
 <param name="g"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Attempt``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary></summary>
 <param name="generator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.BindOrFail``1(Microsoft.FSharp.Core.FSharpChoice{``0,System.String})">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.BindOrRaise``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary></summary>
 <param name="action"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpChoice{``0,``2},``1)">
 <summary></summary>
 <param name="folder"></param>
 <param name="value"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2})">
 <summary></summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary></summary>
 <param name="predicate"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary></summary>
 <param name="predicate"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Bind2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``2,``3}}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
 <summary>
 Applies the specified binding function to a choice value representing a pair of result values (Choice1Of2).
 If the first component of the pair represents an error value, the error is passed through without modification;
 otherwise, if the second component of the pair represents an error value, the error is passed through without
 modification; otherwise, both components represent result values, which are applied to the specified binding function.
 </summary>
 <param name="binding"></param>
 <param name="value1"></param>
 <param name="value2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
 <summary>
 Applies the specified binding function to a choice value representing a result value (Choice1Of2). If the choice
 value represents an error value (Choice2Of2), the error value is passed through without modification.
 </summary>
 <param name="binding"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.MapError``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``0})">
 <summary>
 Applies the specified mapping function to a choice value representing an error value (Choice2Of2). If the choice
 value represents a result value (Choice1Of2), the result value is passed through without modification.
 </summary>
 <param name="mapping"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
 <summary>
 When the choice value is <c>Choice1Of2(x)</c>, returns <c>Choice1Of2 (f x)</c>.
 Otherwise, when the choice value is <c>Choice2Of2(x)</c>, returns <c>Choice2Of2(x)</c>. 
 </summary>
 <param name="mapping"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.ToOption``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.OfOptionWith``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
 <summary></summary>
 <param name="errorValue"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.OfOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.FSharpChoice{``1,System.String}})">
 <summary>
 Creates a Choice representing an error value. The error value in the Choice is the specified formatted error message.
 </summary>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.FailWith``1(System.String)">
 <summary>
 Creates a Choice representing an error value. The error value in the Choice is the specified error message.
 </summary>
 <param name="message">The error message.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Error``2(``0)">
 <summary>Creates a Choice from an error value.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Result``2(``0)">
 <summary>Creates a Choice from a result value.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.GetError``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary>Gets the error value associated with the Choice.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.Get``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary>Gets the result value associated with the Choice.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.IsError``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary>Does the Choice value represent an error value?</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.ChoiceModule.IsResult``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary>Does the Choice value represent a result value?</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.ChoiceModule">
 <summary>Additional functional operators on Choice<_,_> values.</summary>
</member>
<member name="M:ExtCore.OptionModule.Bind2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
 <summary>
 Applies the specified function to two (2) option values when both values are <c>Some</c>. Otherwise, returns <c>None</c>.
 </summary>
 <param name="binder"></param>
 <param name="value1"></param>
 <param name="value2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Filters a option value by applying the given predicate function to the value it contains (if any).</summary>
 <param name="predicate"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.ToOutAndBool``1(Microsoft.FSharp.Core.FSharpOption{``0},``0@)">
 <summary></summary>
 <param name="value"></param>
 <param name="outValue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.Attempt``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Invokes the specified generator function to create a value. If the function returns a value <c>res</c>,
 this function returns <c>Some(res)</c>. If the function raises an exception, it is caught and ignored,
 and <c>None</c> is returned.
 </summary>
 <param name="generator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.TryFillWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Uses the specified function, if necessary, to attempt to create a default value for an option.</summary>
 <param name="generator"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.FillWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Uses the specified function, if necessary, to create a default value for an option.</summary>
 <param name="generator"></param>
 <param name="value"></param>
 <returns></returns>
 <remarks>
 This function is similar to the built-in <see cref="defaultArg"/> operator and <see cref="Option.fill"/>;
 however, those functions require the default value to be created before they are called, while this function
 allows the default value to be created only if it is needed.
 </remarks>
</member>
<member name="M:ExtCore.OptionModule.Fill``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Gets the value of the option if the option is <c>Some</c>, otherwise returns the specified default value.</summary>
 <param name="defaultValue"></param>
 <param name="value"></param>
 <returns></returns>
 <remarks>Identical to the built-in <see cref="defaultArg"/> operator, except with the arguments swapped.</remarks>
</member>
<member name="M:ExtCore.OptionModule.Coalesce``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>
 Chains two option values together.
 If the first value is <c>Some</c>, it is returned; otherwise, the second value is returned.
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 <remarks>
 Similar to the coalesce (??) operator in C#.
 </remarks>
</member>
<member name="M:ExtCore.OptionModule.Condition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0)">
 <summary>
 Applies a predicate function to the given value, returning <c>Some(value)</c>
 when the predicate returns <c>true</c> and <c>None</c> otherwise.
 </summary>
 <param name="predicate"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.Conditional``1(System.Boolean,``0)">
 <summary>
 Creates an F# option from a value <c>x</c>.
 When the specified condition is <c>true</c>, returns <c>Some(x)</c>; otherwise, <c>None</c>.
 </summary>
 <param name="condition"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.ToChoiceWith``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
 <summary></summary>
 <param name="errorValue"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.ToChoice``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.OfChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary></summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.ToNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Creates a nullable value from an F# option.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.OfNullable``1(System.Nullable{``0})">
 <summary>Creates an F# option from a nullable value.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.ToNull``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>
 Creates an instance of a type with the <c>null</c> constraint from an F# option value for that type.
 If the option value is <c>None</c>, returns <c>null</c>. Otherwise, returns the reference contained in the <c>Some</c>.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.OptionModule.OfNull``1(``0)">
 <summary>
 Creates an F# option from an instance of a reference type.
 If the reference is <c>null</c>, returns <c>None</c>; otherwise, returns <c>Some(value)</c>.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.OptionModule">
<summary>
 Additional functional operators on options.
</summary>
</member>
<member name="M:ExtCore.LazyModule.TryForce``1(System.TimeSpan,System.Lazy{``0})">
 <summary>
 Forces evaluation of a lazily-initialized value, if necessary.
 If the evaluation is completed within the specified timeout period, returns <c>Some x</c>
 where <c>x</c> is the initialized value; otherwise, returns None.
 </summary>
 <param name="timeout"></param>
 <param name="lazyValue"></param>
 <returns></returns>
 <remarks>
 If the function returns <c>None</c> because evaluation did not complete in the specified
 timeout period, the evaluation function will continue to run in the background on the
 .NET ThreadPool until it does complete.
 </remarks>
</member>
<member name="M:ExtCore.LazyModule.tryForceCallback``1">
<summary>
 Callback delegate which forces evaluation of a Lazy&lt;&apos;T&gt;,
 then sets a ManualResetEvent to signal the initialization has completed.
 Meant to be used with ThreadPool.QueueUserWorkItem.
</summary>
</member>
<member name="M:ExtCore.LazyModule.Future``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Invokes the specified generator function to create a value in the background using
 the .NET ThreadPool, and immediately returns a lazily-initialized value.
 </summary>
 <param name="creator"></param>
 <returns></returns>
 <remarks>
 When consuming code forces evaluation of this value, it will already be available if the
 generator function has finished executing in the background; otherwise, the calling thread
 is blocked until the generator finishes executing and the value is available.
 </remarks>
</member>
<member name="M:ExtCore.LazyModule.ForceBackground``1(System.Lazy{``0})">
 <summary>Forces evaluation of a lazily-initalized value in the background, using the .NET ThreadPool.</summary>
 <param name="lazyValue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.forceCallback``1">
<summary>
 Callback delegate which forces evaluation of a Lazy&lt;&apos;T&gt;.
 Meant to be used with ThreadPool.QueueUserWorkItem.
</summary>
</member>
<member name="M:ExtCore.LazyModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Lazy{``1}},System.Lazy{``0})">
 <summary></summary>
 <param name="binding"></param>
 <param name="lazyValue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.MapImmediately3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Lazy{``0},System.Lazy{``1},System.Lazy{``2})">
 <summary>Transforms three (3) lazily-initialized values by applying them to the given mapping function.</summary>
 <param name="mapping"></param>
 <param name="lazyValue1"></param>
 <param name="lazyValue2"></param>
 <param name="lazyValue3"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Lazy{``0},System.Lazy{``1},System.Lazy{``2})">
 <summary>Transforms three (3) lazily-initialized values by applying them to the given mapping function.</summary>
 <param name="mapping"></param>
 <param name="lazyValue1"></param>
 <param name="lazyValue2"></param>
 <param name="lazyValue3"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.MapImmediately2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Lazy{``0},System.Lazy{``1})">
 <summary>Transforms two (2) lazily-initialized values by applying them to the given mapping function.</summary>
 <param name="mapping"></param>
 <param name="lazyValue1"></param>
 <param name="lazyValue2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Lazy{``0},System.Lazy{``1})">
 <summary>Transforms two (2) lazily-initialized values by applying them to the given mapping function.</summary>
 <param name="mapping"></param>
 <param name="lazyValue1"></param>
 <param name="lazyValue2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.MapImmediately``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Lazy{``0})">
 <summary>
 Transforms a lazily-initialized value by applying it to the given mapping function.
 </summary>
 <param name="mapping">A mapping function applied to the lazily-initialized value to produce a new value.</param>
 <param name="lazyValue">A lazily-initialized value.</param>
 <returns>
 The lazily-evaluated result of applying <paramref name="mapping"/> to <paramref name="lazyValue"/>.
 </returns>
 <remarks>
 <c>mapImmediately</c> differs from <c>map</c> in that, if the lazily-initialized value
 has already been evaluated, the mapping function is immediately applied to the value.
 This distinction matters primarily when the mapping function has side effects (such as raising an exception),
 since they will occur at different times depending on whether the value has been initialized.
 It is recommended to use <c>map</c> for such cases to ensure side effects are handled uniformly.
 </remarks>
</member>
<member name="M:ExtCore.LazyModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Lazy{``0})">
 <summary>Transforms a lazily-initialized value by applying it to the given mapping function.</summary>
 <param name="mapping">A mapping function applied to the lazily-initialized value to produce a new value.</param>
 <param name="lazyValue">A lazily-initialized value.</param>
 <returns>
 The lazily-evaluated result of applying <paramref name="mapping"/> to <paramref name="lazyValue"/>.
 </returns>
 <c>mapImmediately</c> differs from <c>map</c> in that, if the lazily-initialized value
 has already been evaluated, the mapping function is immediately applied to the value.
 This distinction matters primarily when the mapping function has side effects (such as raising an exception),
 since they will occur at different times depending on whether the value has been initialized.
 It is recommended to use <c>map</c> for such cases to ensure side effects are handled uniformly.
 </remarks>
</member>
<member name="M:ExtCore.LazyModule.TryGetValue``1(System.Lazy{``0})">
 <summary>
 Returns the value of a lazily-initialized value as <c>Some(value)</c> if it has already
 been initialized; otherwise, returns <c>None</c>.
 </summary>
 <param name="lazyValue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.Init``1(``0)">
 <summary>
 Creates a lazily-initialized value which is immediately initialized to the given value. In other words, the
 <see cref="Lazy`1"/> value returned by this function will not need to execute a thunk when forced -- it can
 just return the value it was initialized with.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.Create``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Creates a lazily-initialized value. When the lazy initialization occurs, the specified function is used to create the value.
 </summary>
 <param name="creator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.Value``1(System.Lazy{``0})">
 <summary>Retrieves the value from a lazily-initialized value.</summary>
 <param name="lazyValue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.LazyModule.Force``1(System.Lazy{``0})">
 <summary>
 Forces initialization of a lazily-initialized value (if it has not already been initialized) then returns the value.
 </summary>
 <param name="lazyValue"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.LazyModule">
<summary>
 Functional operators on lazily-initialized values.
</summary>
</member>
<member name="M:ExtCore.EnumModule.IsDefined``1(``0)">
 <summary>Indicates whether a constant with the specified value exists in the given enumeration type.</summary>
 <typeparam name="Enum"></typeparam>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.EnumModule.Values``1">
 <summary>Contains an array of the values defined by an enumeration type.</summary>
 <typeparam name="Enum"></typeparam>
 <returns></returns>
</member>
<member name="M:ExtCore.EnumModule.HasFlag``1(``0,``0)">
 <summary>Determines whether one or more bit fields are set in the specified enum value.</summary>
 <typeparam name="Enum"></typeparam>
 <param name="flag"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.EnumModule">
<summary>
 Functional operators on enumerations.
</summary>
</member>
<member name="M:ExtCore.Operators.ComparisonPattern(System.Int32)">
 <summary>Classifies the result of a comparison.</summary>
 <param name="comparisonResult"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.SuccessOrErrorPattern``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
 <summary>Classifies a Choice`2 value as a successful result or an error.</summary>
 <param name="result"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.CheckFiniteSingle(System.Single)">
 <summary>Checks whether a single-precision floating-point value is a
 finite real number and raises an exception if it is not.</summary>
 <param name="value">The value to check.</param>
 <returns>The unmodified input value, if it is a finite real number.</summary>
 <exception cref="T:System.ArithmeticException"><paramref name="value"/> is a <c>NaN</c> or an infinity</exception>
</member>
<member name="M:ExtCore.Operators.CheckFiniteDouble(System.Double)">
 <summary>Checks whether a double-precision floating-point value is a
 finite real number and raises an exception if it is not.</summary>
 <param name="value">The value to check.</param>
 <returns>The unmodified input value, if it is a finite real number.</summary>
 <exception cref="T:System.ArithmeticException"><paramref name="value"/> is a <c>NaN</c> or an infinity</exception>
</member>
<member name="M:ExtCore.Operators.CheckNonNull``1(System.String,``0)">
 <summary>
 Determines if a reference is a null reference, and if it is, throws an <see cref="System.ArgumentNullException"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="paramName">The name of the parameter that causes this exception.</param>
 <param name="arg">The reference to check.</param>
</member>
<member name="M:ExtCore.Operators.RaiseKeyNotFoundException``1(System.String)">
 <summary>Raises a <see cref="System.Collections.Generic.KeyNotFoundException"/>.</summary>
 <param name="message">The exception message.</param>
</member>
<member name="M:ExtCore.Operators.RaiseArgumentOutOfRangeException``1(System.String,System.String)">
 <summary>Raises an <see cref="System.ArgumentOutOfRangeException"/>.</summary>
 <param name="paramName">The name of the parameter that causes this exception.</param>
 <param name="message">The exception message.</param>
</member>
<member name="M:ExtCore.Operators.RaiseNotSupportedException``1(System.String)">
 <summary>Raises a <see cref="System.NotSupportedException"/>.</summary>
 <param name="message">The exception message.</param>
</member>
<member name="M:ExtCore.Operators.RaiseNotImplementedException``1(System.String)">
 <summary>Raises a <see cref="System.NotImplementedException"/>.</summary>
 <param name="message">The exception message.</param>
</member>
<member name="M:ExtCore.Operators.MaxWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
 <summary>Applies a mapping function to two (2) values, returning the larger (greater) of the resulting values.</summary>
</member>
<member name="M:ExtCore.Operators.MinWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
 <summary>Applies a mapping function to two (2) values, returning the smaller (lesser) of the resulting values.</summary>
</member>
<member name="M:ExtCore.Operators.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
 <summary>
 Applies a mapping function to two (2) values, returning the input value
 whose mapped value was the larger (greater) of the mapped values.
 </summary>
</member>
<member name="M:ExtCore.Operators.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
 <summary>
 Applies a mapping function to two (2) values, returning the input value
 whose mapped value was the smaller (lesser) of the mapped values.
 </summary>
</member>
<member name="M:ExtCore.Operators.TryLock``2(System.TimeSpan,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Attempt to execute the function as a mutual-exclusion region using the input value as a lock. If the lock cannot be entered
 within a specified period of time, the attempt is abandoned and the function returns <c>None</c>.
 </summary>
</member>
<member name="M:ExtCore.Operators.TapAssert``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},``0)">
 <summary>
 Applies the specified value to a function which can possibly return an error message.
 If the function returns an error message, it is used to invoke <see cref="Debug.Fail"/>;
 otherwise, the value is returned unchanged.
 This function is designed for implementing debugging assertions within a computation 'pipeline'.
 </summary>
</member>
<member name="M:ExtCore.Operators.Xorf``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0)">
 <summary>Combines two predicates using the XOR (exclusive-or) operator.</summary>
</member>
<member name="M:ExtCore.Operators.Andf``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0)">
 <summary>Combines two predicates using a short-circuiting AND operator.</summary>
</member>
<member name="M:ExtCore.Operators.Orf``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0)">
 <summary>Combines two predicates using a short-circuiting OR operator.</summary>
</member>
<member name="M:ExtCore.Operators.NotLazy``1(``0)">
 <summary>
 Creates a 'lazy' value whose value is immediately available;
 that is, it does not need to execute a thunk to compute it's value.
 </summary>
</member>
<member name="M:ExtCore.Operators.Tap``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0)">
 <summary>
 Intercepts a value within a pipeline. The value is applied to a given function, then returned so it can
 continue through the pipeline. This function is primarily useful for debugging pipelines.
 </summary>
 <param name="arg1"></param>
 <param name="arg2"></param>
 <param name="arg3"></param>
 <param name="arg4"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.Xnor(System.Boolean,System.Boolean)">
 <summary>If-and-only-if (XNOR) of two boolean values.</summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns></returns>
 <remarks>Also known as the logical biconditional.</remarks>
</member>
<member name="M:ExtCore.Operators.Xor(System.Boolean,System.Boolean)">
 <summary>Exclusive-or (XOR) of two boolean values.</summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.Nor(System.Boolean,System.Boolean)">
 <summary>Not-OR (NOR) of two boolean values.</summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns><c>true</c> when both values are <c>false</c>; otherwise, returns <c>false</c>.</returns>
</member>
<member name="M:ExtCore.Operators.Nand(System.Boolean,System.Boolean)">
 <summary>Not-AND (NAND) of two boolean values.</summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns><c>false</c> when both values are <c>true</c>; otherwise, returns <c>true</c>.</returns>
</member>
<member name="M:ExtCore.Operators.IsNull``1(``0)">
 <summary>Determines if a reference is a null reference.</summary>
 <param name="arg"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.RefEquals``2(``0,``1)">
 <summary>Compares two objects for reference equality.</summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.Flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
 <summary>Swaps the order of the arguments to a function.</summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.Swap``2(``0,``1)">
 <summary>Swaps the values of a tuple so their order is reversed.</summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.op_PercentQmark``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>The opticons ("optional cons") operator.</summary>
 <param name="x"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.op_BangEqualsEquals``1(``0,``0)">
<summary>
 Negated reference/physical-equality operator.
</summary>
</member>
<member name="M:ExtCore.Operators.op_EqualsEqualsEquals``1(``0,``0)">
 <summary>Reference (physical) equality.</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.op_EqualsEquals``1(``0,``0)">
 <summary>Reference (physical) equality.</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns></returns>
</member>
<member name="M:ExtCore.Operators.List`1.GetSlice``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Implements F# slicing syntax for ResizeArray<'T>.</summary>
 <param name="startIndex"></param>
 <param name="finishIndex"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Operators">
<summary>
 Basic F# Operators. This module is automatically opened in all F# code.
</summary>
</member>
<member name="M:ExtCore.SubstringExtensions.Regex.Match(System.Text.RegularExpressions.Regex,ExtCore.Substring)">
 <summary>Searches the input substring for the first occurrence of a regular expression.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringExtensions.StringBuilder.AppendLine(System.Text.StringBuilder,ExtCore.Substring)">
 <summary>Appends a copy of the specified substring to this instance, appending a newline.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringExtensions.StringBuilder.Append(System.Text.StringBuilder,ExtCore.Substring)">
 <summary>Appends a copy of the specified substring to this instance.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringExtensions.String.GetSlice(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns a new substring created from this string and the given starting and ending indices.</summary>
 <param name="startIndex"></param>
 <param name="finishIndex"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.SubstringExtensions">
 <summary>
 Extension methods for <see cref="System.String"/> and <see cref="System.Text.StringBuilder"/>
 which provide integration with the substring type.
 </summary>
</member>
<member name="M:ExtCore.SubstringModule.Trim(System.Char[],ExtCore.Substring)">
 <summary>Removes all leading and trailing occurrences of the specified characters from a substring.</summary>
 <param name="chars"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TrimEnd(System.Char[],ExtCore.Substring)">
 <summary>Removes all trailing occurrences of the specified set of characters from a substring.</summary>
 <param name="chars"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TrimStart(System.Char[],ExtCore.Substring)">
 <summary>Removes all leading occurrences of the specified set of characters from a substring.</summary>
 <param name="chars"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TrimWith(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Removes all leading and trailing occurrences of characters not satisfying the given predicate from a substring.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TrimEndWith(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Removes all trailing occurrences of characters not satisfying the given predicate from a substring.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TrimStartWith(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Removes all leading occurrences of characters not satisfying the given predicate from a substring.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.Substring,``0)">
 <summary>
 Applies a function to each character of the string, threading an accumulator argument through the computation.
 If the input function is f and the characters are c0...cN then computes f c0 (...(f cN s)).
 </summary>
 <param name="folder"></param>
 <param name="substr"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.FoldIndexed``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,``0}}},``0,ExtCore.Substring)">
 <summary>
 Applies a function to each character of the substring, threading an accumulator argument through the computation.
 The integer index applied to the function is the character's index within the substring.
 If the input function is f and the characters are c0...cN then computes f (...(f s c0)...) cN.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Char,``0}},``0,ExtCore.Substring)">
 <summary>
 Applies a function to each character of the substring, threading an accumulator argument through the computation.
 If the input function is f and the characters are c0...cN then computes f (...(f s c0)...) cN.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.IterateIndexedBack(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}},ExtCore.Substring)">
 <summary>
 Applies the given function to each character in the substring, in order from highest to lowest indices.
 The integer index applied to the function is the character's index within the substring.
 </summary>
 <param name="action"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.IterateBack(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit},ExtCore.Substring)">
 <summary>Applies the given function to each character in the substring, in order from highest to lowest indices.</summary>
 <param name="action"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.IterateIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}},ExtCore.Substring)">
 <summary>
 Applies the given function to each character in the substring,
 in order from lowest to highest indices.
 The integer index applied to the function is the character's index within the substring.
 </summary>
 <param name="action"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Iterate(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit},ExtCore.Substring)">
 <summary>Applies the given function to each character in the substring, in order from lowest to highest indices.</summary>
 <param name="action"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Pick``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Substring)">
 <summary>
 Applies the given function to successive characters, returning the first result where the function
 returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>, <c>KeyNotFoundException</c> is raised.
 </summary>
 <param name="picker"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TryPick``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Substring)">
 <summary>
 Applies the given function to successive characters, returning the first result where the function
 returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>, <c>None</c> is returned.
 </summary>
 <param name="picker"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Find(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Returns the first character in the substring which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TryFind(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Returns the first character in the substring which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.FindIndexBack(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Returns the index of the last character in the substring which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TryFindIndexBack(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Returns the index of the last character in the substring which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.FindIndex(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Returns the index of the first character in the substring which satisfies the given predicate.</summary>
</member>
<member name="M:ExtCore.SubstringModule.TryFindIndex(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},ExtCore.Substring)">
 <summary>Returns the index of the first character in the substring which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.FindIndexOfBack(System.Char,ExtCore.Substring)">
 <summary>Returns the index of the last occurrence of a specified character within a substring.</summary>
 <param name="value"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TryFindIndexOfBack(System.Char,ExtCore.Substring)">
 <summary>Returns the index of the last occurrence of a specified character within a substring.</summary>
 <param name="value"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.FindIndexOf(System.Char,ExtCore.Substring)">
 <summary>Returns the index of the first occurrence of a specified character within a substring.</summary>
 <param name="value"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.TryFindIndexOf(System.Char,ExtCore.Substring)">
 <summary>Returns the index of the first occurrence of a specified character within a substring.</summary>
 <param name="value"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Concat(System.Collections.Generic.IEnumerable{ExtCore.Substring})">
 <summary>Builds a new string by concatenating the given sequence of substrings.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Sub(ExtCore.Substring,System.Int32,System.Int32)">
 <summary>Gets a substring of a substring.</summary>
 <param name="substr"></param>
 <param name="offset"></param>
 <param name="count"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Read(ExtCore.Substring)">
 <summary>
 Extracts the first (left-most) character from a substring, returning a <c>Some</c> value
 containing the character and the remaining substring.
 Returns <c>None</c> if the given substring is empty.
 </summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.EndsWith(System.String,ExtCore.Substring)">
 <summary>Determines whether the end of a substring matches the specified string.</summary>
 <param name="value"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.StartsWith(System.String,ExtCore.Substring)">
 <summary>Determines whether the beginning of a substring matches the specified string.</summary>
 <param name="value"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.ToArray(ExtCore.Substring)">
 <summary>Returns the characters in the given substring as a Unicode character array.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.ToString(ExtCore.Substring)">
 <summary>Instantiates the substring as a string.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.OfString(System.String)">
 <summary>Returns a substring which covers the entire length of the given string.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.IsEmpty(ExtCore.Substring)">
 <summary>Is the substring empty?</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Get(ExtCore.Substring,System.Int32)">
 <summary>Gets a character from the substring.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Length(ExtCore.Substring)">
 <summary>Returns the length of the substring.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Offset(ExtCore.Substring)">
 <summary>The starting offset of the substring within it's underlying string.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.String(ExtCore.Substring)">
 <summary>Returns the string underlying the given substring.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="P:ExtCore.SubstringModule.Empty">
<summary>
 An empty substring value.
</summary>
</member>
<member name="M:ExtCore.SubstringModule.Split.FoldIndexed``1(System.Char[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,``0}}},``0,ExtCore.Substring)">
 <summary>
 Applies the given function to each of the substrings in the input string that are delimited by elements of a specified
 Unicode character array, threading an accumulator argument through the computation. The integer index applied to the function
 is the index of the substring within the virtual array of substrings in the input string. For example, if the newline character
 (\n) is used as the separator, the index of each substring would be the line number.
 </summary>
 <param name="separator"></param>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Split.Fold``1(System.Char[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,``0}},``0,ExtCore.Substring)">
 <summary>
 Applies the given function to each of the substrings in the input string that are delimited by elements of a specified
 Unicode character array, threading an accumulator argument through the computation.
 </summary>
 <param name="separator"></param>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Split.IterateIndexed(System.Char[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,Microsoft.FSharp.Core.Unit}},ExtCore.Substring)">
 <summary>
 Applies the given function to each of the substrings in the input string that are delimited by elements of a specified
 Unicode character array. The integer index applied to the function is the index of the substring within the virtual array
 of substrings in the input string. For example, if the newline character (\n) is used as the separator, the index of each
 substring would be the line number.
 </summary>
 <param name="separator"></param>
 <param name="action"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.SubstringModule.Split.Iterate(System.Char[],Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,Microsoft.FSharp.Core.Unit},ExtCore.Substring)">
 <summary>
 Applies the given function to each of the substrings in the input string that are
 delimited by elements of a specified Unicode character array.
 </summary>
 <param name="separator"></param>
 <param name="action"></param>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.SubstringModule.Split">
<summary>
 Substring-splitting functions.
 These functions are analagous to calling the String.Split method with StringSplitOptions.None,
 but are faster because they avoid creating the intermediate array of substrings.
</summary>
</member>
<member name="T:ExtCore.SubstringModule">
<summary>
 Functional operators related to substrings.
</summary>
</member>
<member name="M:ExtCore.StringModule.TrimWith(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Removes all leading and trailing occurrences of characters satisfying the given predicate from a string.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TrimEndWith(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Removes all trailing occurrences of characters satisfying the given predicate from a string.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TrimStartWith(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Removes all leading occurrences of characters satisfying the given predicate from a string.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TrimEnd(System.Char[],System.String)">
 <summary>Removes all trailing occurrences of the specified set of characters from a string.</summary>
 <param name="trimChars"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TrimStart(System.Char[],System.String)">
 <summary>Removes all leading occurrences of the specified set of characters from a string.</summary>
 <param name="trimChars"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Trim(System.Char[],System.String)">
 <summary>Removes all leading and trailing occurrences of the specified characters from a string.</summary>
 <param name="chars"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.FoldPairwise``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,``0}}},``0,System.String)">
 <summary>
 Applies a function to each character in the string and the character which
 follows it, threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.ChooseIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpOption{System.Char}}},System.String)">
 <summary>
 Applies the given function to each character in the string. Returns the string comprised of the results <c>x</c> where the
 function returns <c>Some(x)</c>. The integer index passed to the function indicates the index of the character being transformed.
 </summary>
 <param name="chooser"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Choose(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpOption{System.Char}},System.String)">
 <summary>
 Applies the given function to each character in the string.
 Returns the string comprised of the results <c>x</c> where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.MapIndexed2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char}}},System.String,System.String)">
 <summary>
 Builds a new string whose characters are the results of applying the given function to the corresponding characters
 of the two strings pairwise, also passing the index of the characters.
 The two inputs strings must have the same length, otherwise <see cref="ArgumentException"/> is raised.
 </summary>
 <param name="mapping"></param>
 <param name="str1"></param>
 <param name="str2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Map2(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char}},System.String,System.String)">
 <summary>
 Builds a new string whose characters are the results of applying the given function to the corresponding characters of the
 two strings pairwise. The two inputs strings must have the same length, otherwise <see cref="ArgumentException"/> is raised.
 </summary>
 <param name="mapping"></param>
 <param name="str1"></param>
 <param name="str2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.MapIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char}},System.String)">
 <summary>
 Builds a new string whose characters are the results of applying the given function to each character of the string.
 The integer index passed to the function indicates the index of the character being transformed.
 </summary>
 <param name="mapping"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Map(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char},System.String)">
 <summary>
 Builds a new string whose characters are the results of applying the given function to each character of the string.
 </summary>
 <param name="mapping"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.IterateIndexed2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}}},System.String,System.String)">
 <summary>
 Applies the given function to pairs of characters drawn from matching indices in two strings, also passing the
 index of the characters. The two strings must have the same length, otherwise an <see cref="ArgumentException"/> is raised.
 </summary>
 <param name="action"></param>
 <param name="str1"></param>
 <param name="str2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Iterate2(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}},System.String,System.String)">
 <summary>
 Applies the given function to pairs of characters drawn from matching indices in two strings.
 The two strings must have the same length, otherwise an <see cref="ArgumentException"/> is raised.
 </summary>
 <param name="action"></param>
 <param name="str1"></param>
 <param name="str2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.IterateIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}},System.String)">
 <summary>
 Applies the given function to each character of the string.
 The integer passed to the function indicates the index of the character.
 </summary>
 <param name="action"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Iterate(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
 <summary>Applies the given function to each character of the string.</summary>
 <param name="action"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.FoldBack2``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.String,System.String,``0)">
 <summary>
 Applies the given function to pairs of characters drawn from matching indices in two strings, threading an accumulator argument
 through the computation. The two strings must have the same length, otherwise an <see cref="ArgumentException"/> is raised.
 If the input function is <c>f</c> and the characters are <c>c0...cN</c> and <c>d0...dN</c> then computes <c>f c0 d0 (...(f cN dN s))</c>.
 </summary>
 <param name="folder"></param>
 <param name="str1"></param>
 <param name="str2"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Fold2``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,``0}}},``0,System.String,System.String)">
 <summary>
 Applies the given function to pairs of characters drawn from matching indices in two strings, threading an accumulator argument
 through the computation. The two strings must have the same length, otherwise an <see cref="ArgumentException"/> is raised. If the
 input function is <c>f</c> and the characters are <c>c0...cN</c> and <c>d0...dN</c> then computes <c>f (...(f s c0 d0)...) cN d0</c>.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="str1"></param>
 <param name="str2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.String,``0)">
 <summary>
 Applies a function to each character of the string, threading an accumulator argument through the computation.
 If the input function is <c>f</c> and the characters are <c>c0...cN</c> then computes <c>f c0 (...(f cN s))</c>.
 </summary>
 <param name="folder"></param>
 <param name="str"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Char,``0}},``0,System.String)">
 <summary>
 Applies a function to each character of the string, threading an accumulator argument through the computation.
 If the input function is <c>f</c> and the characters are <c>c0...cN</c> then computes <c>f (...(f s c0)...) cN</c>.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Pick``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpOption{``0}},System.String)">
 <summary></summary>
 <param name="picker"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TryPick``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpOption{``0}},System.String)">
 <summary></summary>
 <param name="picker"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Find(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Returns the first character in the string which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TryFind(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Returns the first character in the string which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.FindIndex(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Returns the index of the first character in the string which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TryFindIndex(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Returns the index of the first character in the string which satisfies the given predicate.</summary>
 <param name="predicate"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.FindIndexOf(System.Char,System.String)">
 <summary>Returns the index of the first occurrence of a specified character within a string.</summary>
 <param name="c"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.TryFindIndexOf(System.Char,System.String)">
 <summary>Returns the index of the first occurrence of a specified character within a string.</summary>
 <param name="c"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Sub(System.String,System.Int32,System.Int32)">
 <summary>Gets a substring of a string.</summary>
 <param name="str"></param>
 <param name="offset"></param>
 <param name="count"></param>
 <return></return>
</member>
<member name="M:ExtCore.StringModule.ToLines(System.String)">
 <summary>Splits a string into individual lines.</summary>
 <param name="str"></param>
 <return></return>
</member>
<member name="M:ExtCore.StringModule.OfLines(System.String[])">
 <summary>Creates a new string by joining the specified strings using an environment-specific newline character sequence.</summary>
 <param name="lines"></param>
 <return></return>
</member>
<member name="M:ExtCore.StringModule.ConcatArray(System.String[])">
 <summary>Returns a new string created by concatenating the strings in the specified string array.</summary>
 <param name="arr"></param>
 <returns></returns>
 <remarks>This method is empirically known to be the fastest way to concatenate a small number (&lt;10) of short strings.</remarks>
</member>
<member name="M:ExtCore.StringModule.Splits(System.String[],System.String)">
 <summary>
 Returns a string array that contains the substrings in a string that are delimited by elements of a specified string array.
 The returned array will be empty if and only if the input string is empty.
 </summary>
 <param name="strings"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Split(System.Char[],System.String)">
 <summary>
 Returns a string array that contains the substrings in a string that are delimited by elements of the given Unicode character array.
 The returned array will be empty if and only if the input string is empty.
 </summary>
 <param name="chars"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Replace(System.String,System.String,System.String)">
 <summary>
 Returns a new string in which all occurrences of a specified string within the given string are replaced with
 another specified string.
 </summary>
 <param name="oldValue"></param>
 <param name="newValue"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.EndsWith(System.String,System.String)">
 <summary>Determines whether the end of a string matches the specified string.</summary>
 <param name="value"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.StartsWith(System.String,System.String)">
 <summary>Determines whether the beginning of a string matches the specified string.</summary>
 <param name="value"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.ToSubstring(System.String)">
 <summary>Returns a new substring spanning the specified string.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.OfSubstring(ExtCore.Substring)">
 <summary>Returns a new string created by instantiating the substring.</summary>
 <param name="substr"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.ToUpperInvariant(System.String)">
 <summary>Returns a copy of the given string, converted to lowercase using the casing rules of the invariant culture.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.ToLowerInvariant(System.String)">
 <summary>Returns a copy of the given string, converted to lowercase using the casing rules of the invariant culture.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.ToArray(System.String)">
 <summary>Builds a character array from the given string.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.ToOption(System.String)">
 <summary>
 Creates an F# option value from the specified string.
 If the string '<paramref name="s"/>' is null or empty, returns <c>None</c>; otherwise, returns <c>Some(s)</c>.
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.OfArray(System.Char[])">
 <summary>Builds a string from the given character array.</summary>
 <param name="chars"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.OfOption(Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Creates a string from an F# option value. If the option value is <c>None</c>, returns an empty string;
 returns <c>s</c> when the option value is <c>Some(s)</c>.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.IsNullOrEmpty(System.String)">
 <summary>Indicates whether the specified string is null or empty.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.IsEmpty(System.String)">
 <summary>Indicates whether the specified string is empty.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Get(System.String,System.Int32)">
 <summary>Gets a character from a string.</summary>
 <param name="str"></param>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="P:ExtCore.StringModule.Empty">
<summary>
 The empty string literal.
</summary>
</member>
<member name="M:ExtCore.StringModule.Split.FoldIndexed``1(System.Char[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,``0}}},``0,System.String)">
 <summary>
 Applies the given function to each of the substrings in the input string that are delimited by elements of a specified Unicode
 character array, threading an accumulator argument through the computation. The integer index applied to the function is the
 index of the substring within the virtual array of substrings in the input string. For example, if the newline character (\n)
 is used as the separator, the index of each substring would be the line number.
 </summary>
 <param name="separator"></param>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Split.Fold``1(System.Char[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,``0}},``0,System.String)">
 <summary>
 Applies the given function to each of the substrings in the input string that are delimited by elements
 of a specified Unicode character array, threading an accumulator argument through the computation.
 </summary>
 <param name="separator"></param>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Split.IterateIndexed(System.Char[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,Microsoft.FSharp.Core.Unit}},System.String)">
 <summary>
 Applies the given function to each of the substrings in the input string that are delimited by elements of a specified
 Unicode character array. The integer index applied to the function is the index of the substring within the virtual array
 of substrings in the input string. For example, if the newline character (\n) is used as the separator, the index of each
 substring would be the line number.
 </summary>
 <param name="separator"></param>
 <param name="action"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.StringModule.Split.Iterate(System.Char[],Microsoft.FSharp.Core.FSharpFunc{ExtCore.Substring,Microsoft.FSharp.Core.Unit},System.String)">
 <summary>
 Applies the given function to each of the substrings in the input string that are
 delimited by elements of a specified Unicode character array.
 </summary>
 <param name="separator"></param>
 <param name="action"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.StringModule.Split">
 <summary>
 String-splitting functions.
 These functions are analagous calling the <see cref="String.Split"/> method with <c>StringSplitOptions.None</c>,
 but are faster because they avoid creating the intermediate array of strings.
 </summary>
</member>
<member name="T:ExtCore.StringModule">
<summary>
 Additional functional operators on strings.
</summary>
</member>
<member name="M:ExtCore.Collections.IMapReduction`2.Reduce(`1,`1)">
 <summary></summary>
 <param name="value1"></param>
 <param name="value2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.IMapReduction`2.Map(`0)">
 <summary></summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.IMapReduction`2">
 <summary></summary>
 <typeparam name="Key"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="M:ExtCore.Collections.IMapFolder`3.Map(`1)">
 <summary></summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.IMapFolder`3.Fold(`0,`2)">
 <summary></summary>
 <param name="state"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.IMapFolder`3">
 <summary></summary>
 <typeparam name="State"></typeparam>
 <typeparam name="Key"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="F:ExtCore.Collections.ListZipper`1.empty">
 <summary>The empty <see cref="ListZipper`1"/> value.</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.Previous">
 <summary>The previous element (if any).</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.IsEmpty">
 <summary>Is the zipper empty?</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.Empty">
 <summary>The empty <see cref="ListZipper`1"/> value.</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.Current">
 <summary>The current element (if any).</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.Context">
 <summary>The previous element (if any) and current element (if any), based on the zipper's current position.</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.AtStart">
 <summary>Is the zipper positioned prior to the start of the list?</summary>
</member>
<member name="P:ExtCore.Collections.ListZipper`1.AtEnd">
 <summary>Is the zipper positioned after the end of the list?</summary>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.Update(`0)">
 <summary>Creates a new zipper by replacing the current list element with the given value.</summary>
 <param name="value"></param>
 <returns></returns>
 <remarks>
 This is similar to <c>zipper.Remove().Insert(value)</c> except that when the zipper
 is empty, <c>zipper.Update(value)</c> returns an empty zipper.
 </remarks>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.ToList">
 <summary>
 Returns a new list whose elements are the same as those in the zipper, and also in the same order as those in the zipper.
 </summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.Remove">
 <summary>Creates a new zipper by removing the current element from the list.</summary>
 <returns></returns>
 <remarks>No exception is raised if the zipper is empty.</remarks>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.MoveStart">
 <summary>Moves the zipper to the start of the list.</summary>
 <returns></returns>
 <remarks>No exception is raised if the zipper is already at the start of the list.</remarks>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.MoveNext">
 <summary>Moves the zipper forwards by one step.</summary>
 <returns></returns>
 <remarks>No exception is raised if the zipper is already at the end of the list.</remarks>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.MoveEnd">
 <summary>Moves the zipper to the end of the list.</summary>
 <returns></returns>
 <remarks>No exception is raised if the zipper is already at the end of the list.</remarks>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.MoveBack">
 <summary>Moves the zipper backwards by one step.</summary>
 <returns></returns>
 <remarks>No exception is raised if the zipper is already at the start of the list.</remarks>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.Insert(`0)">
 <summary>
 Creates a new zipper by inserting the given value prior to the current list element.
 If the zipper is empty, the new zipper's list is created from the given value.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListZipper`1.#ctor(Microsoft.FSharp.Collections.FSharpList{`0})">
 <summary>Creates a <see cref="ListZipper`1"/> whose initial position is prior to the head element of the given list.</summary>
 <param name="list"></param>
</member>
<member name="T:ExtCore.Collections.ListZipper`1">
 <summary>An implementation of a 'zipper' for F# lists.</summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Collections.BimapDebuggerProxy`2">
<summary>
 Internal. Debugger proxy type for Bimap.
</summary>
</member>
<member name="F:ExtCore.Collections.FSharpBimap`2.empty">
<summary>
 The empty Bimap instance.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpBimap`2.IsEmpty">
<summary>
 Is the Bimap empty?
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpBimap`2.Empty">
<summary>
 The empty Bimap.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpBimap`2.Count">
<summary>
 The number of items in the Bimap.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpBimap`2.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpBimap`2.Equals(System.Object)">
 <inherit />
</member>
<member name="T:ExtCore.Collections.FSharpBimap`2">
 <summary>
 An immutable, bi-directional map. Keys are ordered by F# generic comparison.
 </summary>
 <typeparam name="Key">The type of the keys.</typeparam>
 <typeparam name="Value">The type of the values.</typeparam>
</member>
<member name="T:ExtCore.Collections.TagSet`1">
<summary>
 An IntSet whose values are tagged with a unit-of-measure type.
</summary>
</member>
<member name="F:ExtCore.Collections.FSharpIntSet.empty">
<summary>
 The empty IntSet instance.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.op_Subtraction(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Remove the elements of the second set from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.op_Addition(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Compute the union of two sets.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.MinimumElementSigned">
<summary>
 The minimum signed value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.MinimumElement">
<summary>
 The minimum unsigned value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.MaximumElementSigned">
<summary>
 The maximum signed value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.MaximumElement">
<summary>
 The maximum unsigned value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.IsEmpty">
<summary>
 Is the map empty?
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.Empty">
<summary>
 The empty IntSet.
</summary>
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.Count">
 <inherit />
</member>
<member name="P:ExtCore.Collections.FSharpIntSet.Count">
<summary>
 The number of elements in the IntSet.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.UnionMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.FSharpIntSet})">
<summary>
 Computes the union of a sequence of IntSets.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Union(ExtCore.Collections.FSharpIntSet)">
<summary>
 Computes the union of two IntSets.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Singleton(System.Int32)">
<summary>
 The IntSet containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-Generic-ICollection`1-Remove(System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Remove(System.Int32)">
<summary>
 Removes an element from the domain of the IntSet.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.OfSet(Microsoft.FSharp.Collections.FSharpSet{System.Int32})">
<summary>
 Returns a new IntSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.OfSeq(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 Returns a new IntSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.OfList(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 Returns a new IntSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.OfArray(System.Int32[])">
<summary>
 Returns a new IntSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.IsSubsetOf(ExtCore.Collections.FSharpIntSet)">
<summary>
 Determines if this set is a subset of the given set.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.IsProperSubsetOf(ExtCore.Collections.FSharpIntSet)">
<summary>
 Determines if set1 is a proper subset of set2.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.IntersectMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.FSharpIntSet})">
<summary>
 Computes the intersection of a sequence of IntSets.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Intersect(ExtCore.Collections.FSharpIntSet)">
<summary>
 Computes the intersection of two IntSets.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-IEquatable`1-Equals(ExtCore.Collections.FSharpIntSet)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.ElementString(System.Int32)">
<summary>
 Formats an element value for use within the ToString() method.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Difference(ExtCore.Collections.FSharpIntSet)">
<summary>
 Removes the elements of the specified IntSet from this IntSet.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-Generic-ICollection`1-CopyTo(System.Int32[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-Generic-ICollection`1-Contains(System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Contains(System.Int32)">
<summary>
 Tests if an element is in the domain of the IntSet.
</summary>
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-IComparable`1-CompareTo(ExtCore.Collections.FSharpIntSet)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.System-Collections-Generic-ICollection`1-Add(System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.FSharpIntSet.Add(System.Int32)">
<summary>
 Returns a new IntSet with the element added to this IntSet.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Union(ExtCore.Collections.PatriciaSet32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Computes the union of two PatriciaSet32s.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.SubsetCompare(ExtCore.Collections.PatriciaSet32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Computes the containment ordering for two sets (i.e., determines if one set includes the other).
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Remove(System.UInt32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Remove an item from the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.MinElementSigned(ExtCore.Collections.PatriciaSet32)">
<summary>
 Retrieve the minimum element of the set, treating the
 elements of the set as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.MinElement(ExtCore.Collections.PatriciaSet32)">
<summary>
 Retrieve the minimum element of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.MaxElementSigned(ExtCore.Collections.PatriciaSet32)">
<summary>
 Retrieve the maximum element of the set, treating the
 elements of the set as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.MaxElement(ExtCore.Collections.PatriciaSet32)">
<summary>
 Retrieve the maximum element of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.IsSubsetOf(ExtCore.Collections.PatriciaSet32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Is &apos;set1&apos; a subset of &apos;set2&apos;?
 IsSubset (set1, set2) returns true if all keys in set1 are in set2.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.IsProperSubsetOf(ExtCore.Collections.PatriciaSet32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Is &apos;set1&apos; a proper subset of &apos;set2&apos;?
 IsProperSubset (set1, set2) returns true if all keys in set1 are in set2,
 and at least one element in set2 is not in set1.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Intersect(ExtCore.Collections.PatriciaSet32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Compute the intersection of two PatriciaSet32s.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Difference(ExtCore.Collections.PatriciaSet32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Compute the difference of two PatriciaSet32s.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Count(ExtCore.Collections.PatriciaSet32)">
<summary>
 The number of items (i.e., the cardinality) of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Contains(System.UInt32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Determines if the set contains the given value.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet32.Add(System.UInt32,ExtCore.Collections.PatriciaSet32)">
<summary>
 Insert a binding (key-value pair) into a set. returning a new, updated set.
</summary>
</member>
<member name="T:ExtCore.Collections.PatriciaSet32">
<summary>
 A Patricia trie implementation.
 Used as the underlying data structure for IntSet (and TagSet).
</summary>
</member>
<member name="T:ExtCore.Collections.TagMap`2">
 <summary>Immutable maps with 'tagged' integer keys.</summary>
 <typeparam name="Tag">The measure type used to 'tag' the integer keys of the map.</typeparam>
 <typeparam name="T">The type of the values stored in the map.</typeparam>
</member>
<member name="F:ExtCore.Collections.IntMap`1.empty">
<summary>
 The empty IntMap instance.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.Item(System.Int32,`0)">
 <inherit />
</member>
<member name="P:ExtCore.Collections.IntMap`1.Values">
 <inherit />
</member>
<member name="P:ExtCore.Collections.IntMap`1.Trie">
<summary>
 The internal representation of the IntMap.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.MinimumKeySigned">
<summary>
 The minimum signed key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.MinimumKey">
<summary>
 The minimum unsigned key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.MaximumKeySigned">
<summary>
 The maximum signed key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.MaximumKey">
<summary>
 The maximum unsigned key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.Keys">
 <inherit />
</member>
<member name="P:ExtCore.Collections.IntMap`1.Item(System.Int32)">
 <inherit />
</member>
<member name="P:ExtCore.Collections.IntMap`1.Item(System.Int32)">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Collections.IntMap`1.IsEmpty">
<summary>
 Is the map empty?
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.Empty">
<summary>
 The empty IntMap.
</summary>
</member>
<member name="P:ExtCore.Collections.IntMap`1.Count">
 <inherit />
</member>
<member name="P:ExtCore.Collections.IntMap`1.Count">
<summary>
 The number of bindings in the IntMap.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.Union(ExtCore.Collections.IntMap{`0})">
<summary>
 Returns a new map created by merging the two specified maps.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-IDictionary`2-TryGetValue(System.Int32,`0@)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.TryFind(System.Int32)">
<summary>
 Look up an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.TryAdd(System.Int32,`0)">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.Singleton(System.Int32,`0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-IDictionary`2-Remove(System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-ICollection`1-Remove(System.Collections.Generic.KeyValuePair{System.Int32,`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.Remove(System.Int32)">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.OfSeq(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,`0}})">
<summary>
 Returns a new IntMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.OfMap(Microsoft.FSharp.Collections.FSharpMap{System.Int32,`0})">
<summary>
 Returns a new IntMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.OfList(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,`0}})">
<summary>
 Returns a new IntMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.OfArray(System.Tuple{System.Int32,`0}[])">
<summary>
 Returns a new IntMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.IsSubmapOfBy(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean}},ExtCore.Collections.IntMap{`0})">
<summary>
 Returns true if &apos;other&apos; is a submap of this map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.Intersect(ExtCore.Collections.IntMap{`0})">
<summary>
 Returns the intersection of two maps.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.Find(System.Int32)">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-IEquatable`1-Equals(ExtCore.Collections.IntMap{`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.ElementString(System.Collections.Generic.KeyValuePair{System.Int32,`0})">
<summary>
 Formats an element value for use within the ToString() method.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.Difference(ExtCore.Collections.IntMap{`0})">
<summary>
 Returns a new map created by removing the second map from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-ICollection`1-CopyTo(System.Collections.Generic.KeyValuePair{System.Int32,`0}[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-IDictionary`2-ContainsKey(System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.ContainsKey(System.Int32)">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-ICollection`1-Contains(System.Collections.Generic.KeyValuePair{System.Int32,`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-IComparable`1-CompareTo(ExtCore.Collections.IntMap{`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-IDictionary`2-Add(System.Int32,`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.System-Collections-Generic-ICollection`1-Add(System.Collections.Generic.KeyValuePair{System.Int32,`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntMap`1.Add(System.Int32,`0)">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMap`1.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,`0}})">
<summary>
 Create an IntMap from a sequence of key-value pairs.
</summary>
</member>
<member name="T:ExtCore.Collections.IntMap`1">
 <summary>Immutable maps with integer keys.</summary>
 <typeparam name="T">The type of the values stored in the IntMap.</typeparam>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.Union(ExtCore.Collections.PatriciaMap32{`0},ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Computes the union of two PatriciaMaps.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.TryAdd(System.UInt32,`0,ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
 If a binding already exists for the same key, the map is not altered.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.Remove(System.UInt32,ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Remove the binding with the specified key from the map.
 No exception is thrown if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.MinKeySigned(ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Retrieve the minimum key of the map, treating the
 keys of the map as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.MinKey(ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Retrieve the minimum key of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.MaxKeySigned(ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Retrieve the maximum element of the map, treating the
 keys of the map as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.MaxKey(ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Retrieve the maximum key of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.IsSubmapOfBy(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean}},ExtCore.Collections.PatriciaMap32{`0},ExtCore.Collections.PatriciaMap32{`0})">
 <c>IsSubmapOfBy f t1 t2</c> returns <c>true</c> if all keys in t1 are in t2,
 and when 'f' returns <c>true</c> when applied to their respective values.
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.Intersect(ExtCore.Collections.PatriciaMap32{`0},ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Compute the intersection of two PatriciaMaps.
 If both maps contain a binding with the same key, the binding from
 the first map will be used.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.Difference(ExtCore.Collections.PatriciaMap32{`0},ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Compute the difference of two PatriciaMaps.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap32`1.Add(System.UInt32,`0,ExtCore.Collections.PatriciaMap32{`0})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
</summary>
</member>
<member name="T:ExtCore.Collections.PatriciaMap32`1">
<summary>
 A Patricia trie implementation.
 Used as the underlying data structure for IntMap (and TagMap).
</summary>
</member>
<member name="T:ExtCore.Collections.TagBimap`2">
 <summary>A bi-directional TagMap.</summary>
 <typeparam name="Tag">The tag (measure) type of the keys.</typeparam>
 <typeparam name="Value">The type of the values.</typeparam>
</member>
<member name="M:ExtCore.Collections.IntBimap`1.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.IntBimap`1.Equals(System.Object)">
 <inherit />
</member>
<member name="T:ExtCore.Collections.IntBimap`1">
 <summary>A bi-directional IntMap.</summary>
 <typeparam name="Value">The type of the values.</typeparam>
</member>
<member name="T:ExtCore.Collections.LongTagSet`1">
<summary>
 An LongSet whose values are tagged with a unit-of-measure type.
</summary>
</member>
<member name="F:ExtCore.Collections.LongSet.empty">
<summary>
 The empty LongSet instance.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.op_Subtraction(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Remove the elements of the second set from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.op_Addition(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Compute the union of two sets.
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.MinimumElementSigned">
<summary>
 The minimum signed value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.MinimumElement">
<summary>
 The minimum unsigned value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.MaximumElementSigned">
<summary>
 The maximum signed value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.MaximumElement">
<summary>
 The maximum unsigned value stored in the set.
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongSet.IsEmpty">
<summary>
 Is the map empty?
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.Empty">
<summary>
 The empty LongSet.
</summary>
</member>
<member name="P:ExtCore.Collections.LongSet.Count">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongSet.Count">
<summary>
 The number of elements in the LongSet.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.UnionMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.LongSet})">
<summary>
 Computes the union of a sequence of LongSets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.Union(ExtCore.Collections.LongSet)">
<summary>
 Computes the union of two LongSets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.Singleton(System.Int64)">
<summary>
 The LongSet containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-Generic-ICollection`1-Remove(System.Int64)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.Remove(System.Int64)">
<summary>
 Removes an element from the domain of the LongSet.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.OfSet(Microsoft.FSharp.Collections.FSharpSet{System.Int64})">
<summary>
 Returns a new LongSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.OfSeq(System.Collections.Generic.IEnumerable{System.Int64})">
<summary>
 Returns a new LongSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.OfList(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 Returns a new LongSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.OfArray(System.Int64[])">
<summary>
 Returns a new LongSet made from the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.IsSubsetOf(ExtCore.Collections.LongSet)">
<summary>
 Determines if this set is a subset of the given set.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.IsProperSubsetOf(ExtCore.Collections.LongSet)">
<summary>
 Determines if set1 is a proper subset of set2.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.IntersectMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.LongSet})">
<summary>
 Computes the intersection of a sequence of LongSets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.Intersect(ExtCore.Collections.LongSet)">
<summary>
 Computes the intersection of two LongSets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-IEquatable`1-Equals(ExtCore.Collections.LongSet)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.ElementString(System.Int64)">
<summary>
 Formats an element value for use within the ToString() method.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.Difference(ExtCore.Collections.LongSet)">
<summary>
 Removes the elements of the specified LongSet from this LongSet.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-Generic-ICollection`1-CopyTo(System.Int64[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-Generic-ICollection`1-Contains(System.Int64)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.Contains(System.Int64)">
<summary>
 Tests if an element is in the domain of the LongSet.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSet.System-IComparable`1-CompareTo(ExtCore.Collections.LongSet)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.System-Collections-Generic-ICollection`1-Add(System.Int64)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongSet.Add(System.Int64)">
<summary>
 Returns a new LongSet with the element added to this LongSet.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Union(ExtCore.Collections.PatriciaSet64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Computes the union of two PatriciaSet64s.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.SubsetCompare(ExtCore.Collections.PatriciaSet64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Computes the containment ordering for two sets (i.e., determines if one set includes the other).
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Remove(System.UInt64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Remove an item from the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.MinElementSigned(ExtCore.Collections.PatriciaSet64)">
<summary>
 Retrieve the minimum element of the set, treating the
 elements of the set as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.MinElement(ExtCore.Collections.PatriciaSet64)">
<summary>
 Retrieve the minimum element of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.MaxElementSigned(ExtCore.Collections.PatriciaSet64)">
<summary>
 Retrieve the maximum element of the set, treating the
 elements of the set as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.MaxElement(ExtCore.Collections.PatriciaSet64)">
<summary>
 Retrieve the maximum element of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.IsSubsetOf(ExtCore.Collections.PatriciaSet64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Is &apos;set1&apos; a subset of &apos;set2&apos;?
 IsSubset (set1, set2) returns true if all keys in set1 are in set2.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.IsProperSubsetOf(ExtCore.Collections.PatriciaSet64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Is &apos;set1&apos; a proper subset of &apos;set2&apos;?
 IsProperSubset (set1, set2) returns true if all keys in set1 are in set2,
 and at least one element in set2 is not in set1.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Intersect(ExtCore.Collections.PatriciaSet64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Compute the intersection of two PatriciaSet64s.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Difference(ExtCore.Collections.PatriciaSet64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Compute the difference of two PatriciaSet64s.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Count(ExtCore.Collections.PatriciaSet64)">
<summary>
 The number of items (i.e., the cardinality) of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Contains(System.UInt64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Determines if the set contains the given value.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaSet64.Add(System.UInt64,ExtCore.Collections.PatriciaSet64)">
<summary>
 Insert a binding (key-value pair) into a set. returning a new, updated set.
</summary>
</member>
<member name="T:ExtCore.Collections.PatriciaSet64">
<summary>
 A Patricia trie implementation.
 Used as the underlying data structure for LongSet (and LongTagSet).
</summary>
</member>
<member name="T:ExtCore.Collections.LongTagMap`2">
 <summary>Immutable maps with 'tagged' integer keys.</summary>
 <typeparam name="Tag">The measure type used to 'tag' the integer keys of the map.</typeparam>
 <typeparam name="T">The type of the values stored in the map.</typeparam>
</member>
<member name="F:ExtCore.Collections.LongMap`1.empty">
<summary>
 The empty LongMap instance.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.Item(System.Int64,`0)">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongMap`1.Values">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongMap`1.Trie">
<summary>
 The internal representation of the LongMap.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.MinimumKeySigned">
<summary>
 The minimum signed key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.MinimumKey">
<summary>
 The minimum unsigned key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.MaximumKeySigned">
<summary>
 The maximum signed key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.MaximumKey">
<summary>
 The maximum unsigned key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.Keys">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongMap`1.Item(System.Int64)">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongMap`1.Item(System.Int64)">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongMap`1.IsEmpty">
<summary>
 Is the map empty?
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.Empty">
<summary>
 The empty LongMap.
</summary>
</member>
<member name="P:ExtCore.Collections.LongMap`1.Count">
 <inherit />
</member>
<member name="P:ExtCore.Collections.LongMap`1.Count">
<summary>
 The number of bindings in the LongMap.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.Union(ExtCore.Collections.LongMap{`0})">
<summary>
 Returns a new map created by merging the two specified maps.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-IDictionary`2-TryGetValue(System.Int64,`0@)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.TryFind(System.Int64)">
<summary>
 Look up an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.TryAdd(System.Int64,`0)">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.Singleton(System.Int64,`0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-IDictionary`2-Remove(System.Int64)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-ICollection`1-Remove(System.Collections.Generic.KeyValuePair{System.Int64,`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.Remove(System.Int64)">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.OfSeq(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,`0}})">
<summary>
 Returns a new LongMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.OfMap(Microsoft.FSharp.Collections.FSharpMap{System.Int64,`0})">
<summary>
 Returns a new LongMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.OfList(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int64,`0}})">
<summary>
 Returns a new LongMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.OfArray(System.Tuple{System.Int64,`0}[])">
<summary>
 Returns a new LongMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.IsSubmapOfBy(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean}},ExtCore.Collections.LongMap{`0})">
<summary>
 Returns true if &apos;other&apos; is a submap of this map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.Intersect(ExtCore.Collections.LongMap{`0})">
<summary>
 Returns the intersection of two maps.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.Find(System.Int64)">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-IEquatable`1-Equals(ExtCore.Collections.LongMap{`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.ElementString(System.Collections.Generic.KeyValuePair{System.Int64,`0})">
<summary>
 Formats an element value for use within the ToString() method.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.Difference(ExtCore.Collections.LongMap{`0})">
<summary>
 Returns a new map created by removing the second map from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-ICollection`1-CopyTo(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-IDictionary`2-ContainsKey(System.Int64)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.ContainsKey(System.Int64)">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-ICollection`1-Contains(System.Collections.Generic.KeyValuePair{System.Int64,`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-IComparable`1-CompareTo(ExtCore.Collections.LongMap{`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-IDictionary`2-Add(System.Int64,`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.System-Collections-Generic-ICollection`1-Add(System.Collections.Generic.KeyValuePair{System.Int64,`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongMap`1.Add(System.Int64,`0)">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMap`1.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,`0}})">
<summary>
 Create an LongMap from a sequence of key-value pairs.
</summary>
</member>
<member name="T:ExtCore.Collections.LongMap`1">
 <summary>Immutable maps with integer keys.</summary>
 <typeparam name="T">The type of the values stored in the LongMap.</typeparam>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.Union(ExtCore.Collections.PatriciaMap64{`0},ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Computes the union of two PatriciaMaps.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.TryAdd(System.UInt64,`0,ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
 If a binding already exists for the same key, the map is not altered.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.Remove(System.UInt64,ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Remove the binding with the specified key from the map.
 No exception is thrown if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.MinKeySigned(ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Retrieve the minimum key of the map, treating the
 keys of the map as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.MinKey(ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Retrieve the minimum key of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.MaxKeySigned(ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Retrieve the maximum element of the map, treating the
 keys of the map as signed values.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.MaxKey(ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Retrieve the maximum key of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.IsSubmapOfBy(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean}},ExtCore.Collections.PatriciaMap64{`0},ExtCore.Collections.PatriciaMap64{`0})">
 <c>IsSubmapOfBy f t1 t2</c> returns <c>true</c> if all keys in t1 are in t2,
 and when 'f' returns <c>true</c> when applied to their respective values.
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.Intersect(ExtCore.Collections.PatriciaMap64{`0},ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Compute the intersection of two PatriciaMaps.
 If both maps contain a binding with the same key, the binding from
 the first map will be used.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.Difference(ExtCore.Collections.PatriciaMap64{`0},ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Compute the difference of two PatriciaMaps.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaMap64`1.Add(System.UInt64,`0,ExtCore.Collections.PatriciaMap64{`0})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
</summary>
</member>
<member name="T:ExtCore.Collections.PatriciaMap64`1">
<summary>
 A Patricia trie implementation.
 Used as the underlying data structure for LongMap (and LongTagMap).
</summary>
</member>
<member name="T:ExtCore.Collections.LongTagBimap`2">
 <summary>A bi-directional TagMap.</summary>
 <typeparam name="Tag">The tag (measure) type of the keys.</typeparam>
 <typeparam name="Value">The type of the values.</typeparam>
</member>
<member name="M:ExtCore.Collections.LongBimap`1.GetHashCode">
 <inherit />
</member>
<member name="M:ExtCore.Collections.LongBimap`1.Equals(System.Object)">
 <inherit />
</member>
<member name="T:ExtCore.Collections.LongBimap`1">
 <summary>A bi-directional LongMap.</summary>
 <typeparam name="Value">The type of the values.</typeparam>
</member>
<member name="F:ExtCore.Collections.HashSet`1.comparer">
<summary>
 The comparer for the type of the values contained in this collection.
 It is cached here for fast access.
</summary>
</member>
<member name="F:ExtCore.Collections.HashSet`1.empty">
<summary>
 The empty HashSet instance.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.op_Subtraction(ExtCore.Collections.HashSet{`0},ExtCore.Collections.HashSet{`0})">
<summary>
 Computes the difference of two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.op_Addition(ExtCore.Collections.HashSet{`0},ExtCore.Collections.HashSet{`0})">
<summary>
 Computes the union of two sets.
</summary>
</member>
<member name="P:ExtCore.Collections.HashSet`1.Trie">
<summary>
 The internal representation of the HashSet.
</summary>
</member>
<member name="P:ExtCore.Collections.HashSet`1.Last">
<summary>
 The last element in the set.
 If the element type has suitable hash and comparison functions for the set
 to be ordered, then this will be the maximum element of the set.
</summary>
</member>
<member name="P:ExtCore.Collections.HashSet`1.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashSet`1.IsEmpty">
<summary>
 Is the set empty?
</summary>
</member>
<member name="P:ExtCore.Collections.HashSet`1.First">
<summary>
 The first element in the set.
 If the element type has suitable hash and comparison functions for the set
 to be ordered, then this will be the minimum element of the set.
</summary>
</member>
<member name="P:ExtCore.Collections.HashSet`1.Empty">
<summary>
 The empty HashSet.
</summary>
</member>
<member name="P:ExtCore.Collections.HashSet`1.Count">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashSet`1.Count">
<summary>
 The number of bindings in the HashSet.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.UnionMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.HashSet{`0}})">
<summary>
 Computes the union of a sequence of HashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.Union(ExtCore.Collections.HashSet{`0})">
<summary>
 Returns a new HashSet created by merging the two specified HashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.Singleton(`0)">
<summary>
 The HashSet containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-Generic-ICollection`1-Remove(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.Remove(`0)">
<summary>
 Removes an element from the domain of the HashSet.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.OfSeq(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Returns a new HashSet made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.OfList(Microsoft.FSharp.Collections.FSharpList{`0})">
<summary>
 Returns a new HashSet made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.OfArray(`0[])">
<summary>
 Returns a new HashSet made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.IsSubsetOf(ExtCore.Collections.HashSet{`0})">
<summary>
 Determines if this set is a subset of the given set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.IsProperSubsetOf(ExtCore.Collections.HashSet{`0})">
<summary>
 Determines if set1 is a proper subset of set2.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.IntersectMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.HashSet{`0}})">
<summary>
 Computes the intersection of a sequence of HashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.Intersect(ExtCore.Collections.HashSet{`0})">
<summary>
 Returns the intersection of two HashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-IEquatable`1-Equals(ExtCore.Collections.HashSet{`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.ElementString(System.Object)">
<summary>
 Formats an element value for use within the ToString() method.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.Difference(ExtCore.Collections.HashSet{`0})">
<summary>
 Returns a new HashSet created by removing the second HashSet from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-Generic-ICollection`1-CopyTo(`0[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-Generic-ICollection`1-Contains(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.Contains(`0)">
<summary>
 Tests if an element is in the domain of the HashSet.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-IComparable`1-CompareTo(ExtCore.Collections.HashSet{`0})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.System-Collections-Generic-ICollection`1-Add(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashSet`1.Add(`0)">
<summary>
 Returns a new HashSet with the binding added to this HashSet.
</summary>
</member>
<member name="T:ExtCore.Collections.HashSet`1">
 <summary>Immutable, unordered sets based on PATRICIA tries and binary tries.</summary>
 <typeparam name="T">The type of the values stored in the set.</typeparam>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.Union(System.Collections.Generic.IComparer{`0},ExtCore.Collections.PatriciaHashSet{`0},ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Computes the union of two PatriciaHashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.SubsetCompare(System.Collections.Generic.IComparer{`0},ExtCore.Collections.PatriciaHashSet{`0},ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Computes the containment ordering for two sets (i.e., determines if one set includes the other).
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.Remove(System.Collections.Generic.IComparer{`0},System.UInt32,`0,ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Remove the binding with the specified key from the set.
 No exception is thrown if the set.does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.Last(ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Retrieve the last element of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.IsSubsetOf(System.Collections.Generic.IComparer{`0},ExtCore.Collections.PatriciaHashSet{`0},ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Is &apos;set1&apos; a subset of &apos;set2&apos;?
 IsSubset (set1, set2) returns true if all keys in set1 are in set2.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.IsProperSubsetOf(System.Collections.Generic.IComparer{`0},ExtCore.Collections.PatriciaHashSet{`0},ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Is &apos;set1&apos; a proper subset of &apos;set2&apos;?
 IsProperSubset (set1, set2) returns true if all keys in set1 are in set2,
 and at least one element in set2 is not in set1.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.Intersect(System.Collections.Generic.IComparer{`0},ExtCore.Collections.PatriciaHashSet{`0},ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Compute the intersection of two PatriciaHashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.First(ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Retrieve the first element of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.Difference(System.Collections.Generic.IComparer{`0},ExtCore.Collections.PatriciaHashSet{`0},ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Compute the difference of two PatriciaHashSets.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashSet`1.Add(System.Collections.Generic.IComparer{`0},System.UInt32,`0,ExtCore.Collections.PatriciaHashSet{`0})">
<summary>
 Insert a binding (key-value pair) into a set. returning a new, updated set.
</summary>
</member>
<member name="T:ExtCore.Collections.PatriciaHashSet`1">
<summary>
 A Patricia trie implementation, modified so each of it&apos;s &apos;values&apos; is actually a comparison-based set implementation.
 Used as the underlying data structure for HashSet.
</summary>
</member>
<member name="T:ExtCore.Collections.SetTree`1.Node">
<summary>
 Node.
</summary>
</member>
<member name="T:ExtCore.Collections.SetTree`1.Empty">
<summary>
 Empty tree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Union(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},ExtCore.Collections.SetTree{`0})">
<summary>
 Computes the union of two SetTrees.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.TryDeleteMin(ExtCore.Collections.SetTree{`0})">
<summary>
 Removes the minimum (least) value from a SetTree,
 returning the value along with the updated tree.
 No exception is thrown if the tree is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.TryDeleteMax(ExtCore.Collections.SetTree{`0})">
<summary>
 Removes the maximum (greatest) value from a SetTree,
 returning the value along with the updated tree.
 No exception is thrown if the tree is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.ToSeq(ExtCore.Collections.SetTree{`0})">
<summary>
 Returns a sequence containing the elements stored
 in a SetTree, ordered from least to greatest.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.ToList(ExtCore.Collections.SetTree{`0})">
<summary>
 Returns a list containing the elements stored in
 a SetTree, ordered from least to greatest.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.ToArray(ExtCore.Collections.SetTree{`0})">
<summary>
 Returns an array containing the elements stored in
 a SetTree, ordered from least to greatest.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Singleton(`0)">
<summary>
 Creates a SetTree containing the specified value.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.OfSeq(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{`0})">
<summary>
 Builds a new SetTree from the elements of a sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.OfList(System.Collections.Generic.IComparer{`0},Microsoft.FSharp.Collections.FSharpList{`0})">
<summary>
 Builds a new SetTree from the elements of an list.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.OfArray(System.Collections.Generic.IComparer{`0},`0[])">
<summary>
 Builds a new SetTree from the elements of an array.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.MinElement(ExtCore.Collections.SetTree{`0})">
<summary>
 Gets the minimum (least) value stored in the SetTree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.MaxElement(ExtCore.Collections.SetTree{`0})">
<summary>
 Gets the maximum (greatest) value stored in the SetTree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.IsEmptyTree(ExtCore.Collections.SetTree{`0})">
<summary>
 Determines if a SetTree is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.IntersectionAux(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},ExtCore.Collections.SetTree{`0},ExtCore.Collections.SetTree{`0})">
<summary>
 Implementation. Computes the intersection of two SetTrees.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Intersection(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},ExtCore.Collections.SetTree{`0})">
<summary>
 Computes the intersection of two SetTrees.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Insert(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},`0)">
<summary>
 Adds a value to a SetTree.
 If the tree already contains the value, no exception is thrown;
 the tree will be returned without modification.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.HeightDiff``1(ExtCore.Collections.SetTree{``0},ExtCore.Collections.SetTree{`0})">
<summary>
 Returns the absolute difference in heights between two SetTrees.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Height(ExtCore.Collections.SetTree{`0})">
<summary>
 Returns the height of a SetTree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Forall(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},ExtCore.Collections.SetTree{`0})">
<summary>
 Tests if all elements of the collection satisfy the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.Collections.SetTree{`0},``0)">
<summary>
 Applies the given accumulating function to all elements in a SetTree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,``0}},``0,ExtCore.Collections.SetTree{`0})">
<summary>
 Applies the given accumulating function to all elements in a SetTree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},ExtCore.Collections.SetTree{`0})">
<summary>
 Tests if any element of the collection satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Difference(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},ExtCore.Collections.SetTree{`0})">
<summary>
 Returns a new SetTree created by removing the elements of the second SetTree from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.DeleteRoot(ExtCore.Collections.SetTree{`0})">
<summary>
 Removes the root (median) value from an SetTree,
 returning the value along with the updated tree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.DeleteMin(ExtCore.Collections.SetTree{`0})">
<summary>
 Removes the minimum (least) value from an SetTree,
 returning the value along with the updated tree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.DeleteMax(ExtCore.Collections.SetTree{`0})">
<summary>
 Removes the maximum (greatest) value from an SetTree,
 returning the value along with the updated tree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Delete(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},`0)">
<summary>
 Removes the specified value from the tree.
 If the tree doesn&apos;t contain the value, no exception is thrown;
 the tree will be returned without modification.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Create(`0,ExtCore.Collections.SetTree{`0},ExtCore.Collections.SetTree{`0})">
<summary>
 Creates a SetTree whose root node holds the specified value
 and the specified left and right subtrees.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Count(ExtCore.Collections.SetTree{`0})">
<summary>
 Counts the number of elements in the tree.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.Contains(System.Collections.Generic.IComparer{`0},ExtCore.Collections.SetTree{`0},`0)">
<summary>
 Determines if a SetTree contains a specified value.
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.ComputeHeight(ExtCore.Collections.SetTree{`0})">
<summary>
 Computes the height of a SetTree (rather than returning the height value stored in it&apos;s root).
</summary>
</member>
<member name="M:ExtCore.Collections.SetTree`1.AvlInvariant(ExtCore.Collections.SetTree{`0})">
<summary>
 Determines if a SetTree is correctly formed, i.e., it respects the AVL balancing rules.
</summary>
</member>
<member name="T:ExtCore.Collections.SetTree`1">
<summary>
 SetTree which serves as the internal representation of the Set type.
</summary>
</member>
<member name="F:ExtCore.Collections.HashMap`2.comparer">
<summary>
 The comparer for the type of the keys used by this collection.
 It is cached here for fast access.
</summary>
</member>
<member name="F:ExtCore.Collections.HashMap`2.empty">
<summary>
 The empty HashMap instance.
</summary>
</member>
<member name="P:ExtCore.Collections.HashMap`2.Item(`0,`1)">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashMap`2.Values">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashMap`2.Trie">
<summary>
 The internal representation of the HashMap.
</summary>
</member>
<member name="P:ExtCore.Collections.HashMap`2.Keys">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashMap`2.Item(`0)">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashMap`2.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashMap`2.IsEmpty">
<summary>
 Is the map empty?
</summary>
</member>
<member name="P:ExtCore.Collections.HashMap`2.Empty">
<summary>
 The empty HashMap.
</summary>
</member>
<member name="P:ExtCore.Collections.HashMap`2.Count">
 <inherit />
</member>
<member name="P:ExtCore.Collections.HashMap`2.Count">
<summary>
 The number of bindings in the HashMap.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-IDictionary`2-TryGetValue(`0,`1@)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.TryFind(`0)">
<summary>
 Look up an element in the HashMap returning a Some value if the
 element is in the domain of the HashMap and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.TryAdd(`0,`1)">
<summary>
 Returns a new HashMap with the binding added to this HashMap.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.Singleton(`0,`1)">
<summary>
 The HashMap containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-IDictionary`2-Remove(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-ICollection`1-Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.Remove(`0)">
<summary>
 Removes an element from the domain of the HashMap.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.OfSeq(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Returns a new HashMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.OfMap(Microsoft.FSharp.Collections.FSharpMap{`0,`1})">
<summary>
 Returns a new HashMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.OfList(Microsoft.FSharp.Collections.FSharpList{System.Tuple{`0,`1}})">
<summary>
 Returns a new HashMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.OfArray(System.Tuple{`0,`1}[])">
<summary>
 Returns a new HashMap made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.Find(`0)">
<summary>
 Look up an element in the HashMap, raising KeyNotFoundException
 if no binding exists in the HashMap.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-IEquatable`1-Equals(ExtCore.Collections.HashMap{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.Equals(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.ElementString(System.Object)">
<summary>
 Formats an element value for use within the ToString() method.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-ICollection`1-CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-IDictionary`2-ContainsKey(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.ContainsKey(`0)">
<summary>
 Tests if an element is in the domain of the HashMap.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-ICollection`1-Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-IComparable`1-CompareTo(ExtCore.Collections.HashMap{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-IComparable-CompareTo(System.Object)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-IDictionary`2-Add(`0,`1)">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.System-Collections-Generic-ICollection`1-Add(System.Collections.Generic.KeyValuePair{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Collections.HashMap`2.Add(`0,`1)">
<summary>
 Returns a new HashMap with the binding added to this HashMap.
</summary>
</member>
<member name="T:ExtCore.Collections.HashMap`2">
 <summary>Immutable, unordered maps based on PATRICIA tries and binary tries.</summary>
 <typeparam name="Key">The type of key used by the map.</typeparam>
 <typeparam name="T">The type of the values stored in the map.</typeparam>
</member>
<member name="M:ExtCore.Collections.PatriciaHashMap`2.TryAdd(System.Collections.Generic.IComparer{`0},`0,`1,ExtCore.Collections.PatriciaHashMap{`0,`1})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
 If a binding already exists for the same key, the map is not altered.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashMap`2.TryAdd(System.Collections.Generic.IComparer{`0},System.UInt32,`0,`1,ExtCore.Collections.PatriciaHashMap{`0,`1})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
 If a binding already exists for the same key, the map is not altered.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashMap`2.Remove(System.Collections.Generic.IComparer{`0},System.UInt32,`0,ExtCore.Collections.PatriciaHashMap{`0,`1})">
<summary>
 Remove the binding with the specified key from the map.
 No exception is thrown if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.PatriciaHashMap`2.Add(System.Collections.Generic.IComparer{`0},System.UInt32,`0,`1,ExtCore.Collections.PatriciaHashMap{`0,`1})">
<summary>
 Insert a binding (key-value pair) into a map, returning a new, updated map.
</summary>
</member>
<member name="T:ExtCore.Collections.PatriciaHashMap`2">
<summary>
 A Patricia trie implementation, modified so each of it&apos;s &apos;values&apos; is actually a comparison-based set.
 Used as the underlying data structure for HashMap.
</summary>
</member>
<member name="T:ExtCore.Collections.MapTree`2.Node">
<summary>
 Node.
</summary>
</member>
<member name="T:ExtCore.Collections.MapTree`2.Empty">
<summary>
 Empty tree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.TryInsert(System.Collections.Generic.IComparer{`0},ExtCore.Collections.MapTree{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
<summary>
 Adds a value to a MapTree.
 If the tree already contains a binding with an equivalent key *and* value, no exception is thrown;
 the tree is returned without modification.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.TryFindByKey(System.Collections.Generic.IComparer{`0},ExtCore.Collections.MapTree{`0,`1},`0)">
<summary>
 Try to find a value associated with the specified key in a MapTree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.TryDeleteMin(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Removes the minimum (least) value from a MapTree,
 returning the value along with the updated tree.
 No exception is thrown if the tree is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.TryDeleteMax(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Removes the maximum (greatest) value from a MapTree,
 returning the value along with the updated tree.
 No exception is thrown if the tree is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.ToSeq(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Returns a sequence containing the elements stored
 in a MapTree, ordered from least to greatest.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.ToList(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Returns a list containing the elements stored in
 a MapTree, ordered from least to greatest. 
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.ToArray(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Returns an array containing the elements stored in
 a MapTree, ordered from least to greatest.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Singleton(System.Collections.Generic.KeyValuePair{`0,`1})">
<summary>
 Creates a MapTree containing the specified key-value pair.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.OfSeq(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Builds a new MapTree from the elements of a sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.OfList(System.Collections.Generic.IComparer{`0},Microsoft.FSharp.Collections.FSharpList{System.Tuple{`0,`1}})">
<summary>
 Builds a new MapTree from the elements of an list.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.OfArray(System.Collections.Generic.IComparer{`0},System.Tuple{`0,`1}[])">
<summary>
 Builds a new MapTree from the elements of an array.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.MinElement(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Gets the minimum (least) value stored in the MapTree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.MaxElement(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Gets the maximum (greatest) value stored in the MapTree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.IsEmptyTree(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Determines if a MapTree is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Insert(System.Collections.Generic.IComparer{`0},ExtCore.Collections.MapTree{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
<summary>
 Adds a value to a MapTree.
 If the tree already contains a binding with an equivalent key *and* value, no exception is thrown;
 the tree is returned without modification.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.HeightDiff``2(ExtCore.Collections.MapTree{``0,``1},ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Returns the absolute difference in heights between two MapTrees.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Height(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Returns the height of a MapTree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Forall(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}},ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Tests if all elements of the collection satisfy the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},ExtCore.Collections.MapTree{`0,`1},``0)">
<summary>
 Applies the given accumulating function to all elements in a MapTree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}}},``0,ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Applies the given accumulating function to all elements in a MapTree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}},ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Tests if any element of the collection satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.DeleteRoot(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Removes the root (median) value from an MapTree,
 returning the value along with the updated tree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.DeleteMin(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Removes the minimum (least) value from an MapTree,
 returning the value along with the updated tree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.DeleteMax(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Removes the maximum (greatest) value from an MapTree,
 returning the value along with the updated tree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Delete(System.Collections.Generic.IComparer{`0},ExtCore.Collections.MapTree{`0,`1},`0)">
<summary>
 Removes the specified value from the tree.
 If the tree doesn&apos;t contain the value, no exception is thrown;
 the tree will be returned without modification.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Create(System.Collections.Generic.KeyValuePair{`0,`1},ExtCore.Collections.MapTree{`0,`1},ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Creates a MapTree whose root node holds the specified value
 and the specified left and right subtrees.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.Count(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Counts the number of elements in the tree.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.ContainsKey(System.Collections.Generic.IComparer{`0},ExtCore.Collections.MapTree{`0,`1},`0)">
<summary>
 Determines if a MapTree contains a specified value.
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.ComputeHeight(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Computes the height of a MapTree (rather than returning the height value stored in it&apos;s root).
</summary>
</member>
<member name="M:ExtCore.Collections.MapTree`2.AvlInvariant(ExtCore.Collections.MapTree{`0,`1})">
<summary>
 Determines if a MapTree is correctly formed, i.e., it respects the AVL balancing rules.
</summary>
</member>
<member name="T:ExtCore.Collections.MapTree`2">
<summary>
 AVL tree which serves as the internal representation of the Map type.
</summary>
</member>
<member name="T:ExtCore.Collections.Multiset`1">
<summary>
 Immutable multisets. Elements are ordered by F# generic comparison.
</summary>
</member>
<member name="T:ExtCore.Collections.Multimap`2">
<summary>
 Immutable multimaps. Elements are ordered by F# generic comparison.
</summary>
</member>
<member name="T:ExtCore.Collections.LazyListBuilder">
<summary>
 Computation expression (&quot;workflow&quot;) builder for creating lazy lists.
</summary>
</member>
<member name="F:ExtCore.Collections.LazyList`1.undefinedValue">
<summary>
 The status for undefined values.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.op_PlusPlus(ExtCore.Collections.LazyList{`0},ExtCore.Collections.LazyList{`0})">
 <summary>Appends the second <see cref="LazyList`1{T}"/> to the end of the first.</summary>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="P:ExtCore.Collections.LazyList`1.LongLength">
 <summary>Determines the length of the list.</summary>
 <remarks>
 Forces the evaluation of the entire list if it is not already evaluated, so calls to this property may not terminate.
 </remarks>
</member>
<member name="P:ExtCore.Collections.LazyList`1.Length">
 <summary>Determines the length of the list.</summary>
 <remarks>
 Forces the evaluation of the entire list if it is not already evaluated, so calls to this property may not terminate.
 </remarks>
</member>
<member name="P:ExtCore.Collections.LazyList`1.IsEmpty">
 <summary>Gets a value that indicates whether the <see cref="T:LazyList`1{T}"/> is empty.</summary>
 <remarks>Forces the evaluation of the first element of the stream if it is not already evaluated.</remarks>
</member>
<member name="P:ExtCore.Collections.LazyList`1.ForcedLength">
 <summary>Determines the evaluated length of the list.</summary>
 <remarks>This does not force any evaluation of the list.</remarks>
</member>
<member name="P:ExtCore.Collections.LazyList`1.Empty">
 <summary>The empty LazyList.</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.TryHeadTail">
 <summary>Get the first cell of the list.</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.ToSeq">
 <summary>Creates a sequence which enumerates the values in the <see cref="LazyList`1{T}"/>.</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Tail">
 <summary>Return the list corresponding to the remaining items in the sequence.</summary>
 <remarks>Forces the evaluation of the first cell of the list if it is not already evaluated.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Head">
 <summary>Return the first element of the list.</summary>
 <remarks>Forces the evaluation of the first cell of the list if it is not already evaluated.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Delayed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{`0}})">
 <summary>
 Return a list that is -- in effect -- the list returned by the given computation.
 The given computation is not executed until the first element on the list is consumed.
 </summary>
 <param name="creator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyList`1.CreateLazy(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyListCell{`0}})">
 <summary></summary>
 <param name="cellCreator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyList`1.ConsDelayed(`0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{`0}})">
 <summary>
 Return a new list which on consumption contains the given item followed by the list returned by the given computation.
 </summary>
 <param name="value"></param>
 <param name="creator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Cons(`0,ExtCore.Collections.LazyList{`0})">
 <summary>Return a new list which contains the given item followed by the given list.</summary>
 <param name="value"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.LazyList`1">
 <summary>
 LazyLists are possibly-infinite, cached sequences.
 LazyLists normally involve delayed computations without side-effects.
 The results of these computations are cached and evaluations will be performed only once for each element of the LazyList.
 In contrast, for sequences (seq{T}) recomputation happens each time an enumerator is created and the sequence traversed.
 </summary>
 <typeparam name="T">The type of elements in the list.</typeparam>
 <remarks>
 <para>
 LazyLists can represent cached, potentially-infinite computations. Because they are 
 cached they may cause memory leaks if some active code or data structure maintains a 
 live reference to the head of an infinite or very large lazy list while iterating it, 
 or if a reference is maintained after the list is no longer required.
 </para>
 <para>
 Lazy lists may be destructured for pattern matching using the <c>(|Nil|Cons|)</c> active pattern
 in the <c>LazyListPatterns</c> module. Note that using the active patterns to destructure a LazyList
 may force computation of elements of the list; in turn, this may cause programs to hang or crash
 due to non-termination of the evaluation.
 </para>
 <para>
 See also IEnumerable/Seq for uncached sequences.
 </para>
 </remarks>
</member>
<member name="T:ExtCore.Collections.LazyListCell`1.Cons">
<summary>
 A lazy-list cell holding a value followed by another lazy list.
</summary>
</member>
<member name="T:ExtCore.Collections.LazyListCell`1.Empty">
<summary>
 Empty lazy-list cell.
</summary>
</member>
<member name="T:ExtCore.Collections.LazyListCell`1">
 <summary>A lazy-list cell.</summary>
 <typeparam name="T">The type of elements in the list.</typeparam>
</member>
<member name="T:ExtCore.Collections.LazyCellStatus`1">
 <summary>Represents the evaluation status of a <see cref="T:LazyListCell`1{T}"/>.</summary>
 <typeparam name="T">The type of elements in the list.</typeparam>
</member>
<member name="F:ExtCore.Collections.Queue`1.empty">
<summary>
 The empty queue instance.
 This avoids creating unnecessary instances, since all empty queues are equivalent.
</summary>
</member>
<member name="P:ExtCore.Collections.Queue`1.IsEmpty">
 <summary>Returns <c>true</c> if the given Queue is empty; otherwise, <c>false</c>.</summary>
</member>
<member name="P:ExtCore.Collections.Queue`1.Empty">
<summary>
 The empty queue.
</summary>
</member>
<member name="M:ExtCore.Collections.Queue`1.ToVector">
 <summary>Create a vector containing the elements of the Queue in order.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.ToSeq">
 <summary>Create a sequence containing the elements of the Queue in order.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.ToList">
 <summary>Create a list containing the elements of the Queue in order.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.ToArray">
 <summary>Create an array containing the elements of the Queue in order.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.Rotate(ExtCore.Collections.LazyList{`0},Microsoft.FSharp.Collections.FSharpList{`0},ExtCore.Collections.LazyList{`0})">
<summary>
 Performs the &apos;rotate&apos; operation on a Queue, given the private fields holding the queue elements.
</summary>
</member>
<member name="M:ExtCore.Collections.Queue`1.OfVector(ExtCore.FSharpVector{`0})">
 <summary>Creates a Queue from the elements of a vector.</summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.OfSeq(System.Collections.Generic.IEnumerable{`0})">
 <summary>Creates a Queue from the elements of an <see cref="IEnumerable`1"/>.</summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.OfList(Microsoft.FSharp.Collections.FSharpList{`0})">
 <summary>Creates a Queue from the elements of a list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.OfArray(`0[])">
 <summary>Creates a Queue from the elements of an array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.GetLength">
 <summary>The number of elements in the Queue.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.Queue`1.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Collections.Queue`1.EnqueueFront(`0)">
 <summary>Returns a new Queue with the object added to the front of the Queue.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.Enqueue(`0)">
 <summary>Returns a new Queue with the object added to the end of the Queue.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.Dequeue">
 <summary>Removes and returns the object at the beginning of the Queue.</summary>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.Queue`1.CreateQueue(ExtCore.Collections.LazyList{`0},Microsoft.FSharp.Collections.FSharpList{`0},ExtCore.Collections.LazyList{`0})">
<summary>
 Creates a new Queue with the given field values.
</summary>
</member>
<member name="T:ExtCore.Collections.Queue`1">
 <summary>An immutable queue representing a first-in, first-out (FIFO) collection of objects.</summary>
 <typeparam name="T">The type of elements in the queue.</typeparam>
</member>
<member name="M:ExtCore.Collections.AsyncSeqBuilder.TryNext``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Tries to get the next element of an asynchronous sequence
 and returns either the value or an exception.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqBuilder.For``2(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}}})">
<summary>
 Asynchronous for loop - for all elements from the input sequence,
 generate all elements produced by the body (asynchronously).
 See also the AsyncSeq.collect function.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqBuilder.For``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}}})">
<summary>
 For loop that iterates over a synchronous sequence (and generates
 all elements generated by the asynchronous body)
</summary>
</member>
<member name="T:ExtCore.Collections.AsyncSeqBuilder">
<summary>
 Computation builder that allows creating of asynchronous
 sequences using the &apos;asyncSeq { ... }&apos; syntax.
</summary>
</member>
<member name="T:ExtCore.Collections.AsyncSeq`1">
<summary>
 An asynchronous sequence represents a delayed computation that can be
 started to produce either Cons value consisting of the next element of the 
 sequence (head) together with the next asynchronous sequence (tail) or a 
 special value representing the end of the sequence (Nil)
</summary>
</member>
<member name="T:ExtCore.Collections.AsyncSeqItem`1">
<summary>
 The internal type that represents a value returned as a result of
 evaluating a step of an asynchronous sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.KeyValuePairModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.KeyValuePair{``0,``1})">
 <summary>
 Transforms the value in a key/value pair by applying the specified function to it. The key passed to the function
 indicates the key of the value being transformed. This function is analogous to <see cref="Map.map"/>.
 </summary>
</member>
<member name="M:ExtCore.Collections.KeyValuePairModule.Value``2(System.Collections.Generic.KeyValuePair{``0,``1})">
 <summary>Gets the value in the key/value pair.
</member>
<member name="M:ExtCore.Collections.KeyValuePairModule.Key``2(System.Collections.Generic.KeyValuePair{``0,``1})">
 <summary>Gets the key from the key/value pair.
</member>
<member name="T:ExtCore.Collections.KeyValuePairModule">
 <summary>
 Functional programming operators related to the <see cref="System.Collections.Generic.KeyValuePair`2"/> type.
 </summary>
</member>
<member name="M:ExtCore.Collections.RangeModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0,``0)">
 <summary></summary>
 <param name="predicate"></param>
 <param name="start"></param>
 <param name="finish"></param>
 <remarks></remarks>
</member>
<member name="M:ExtCore.Collections.RangeModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0,``0)">
 <summary></summary>
 <param name="predicate"></param>
 <param name="start"></param>
 <param name="finish"></param>
 <remarks></remarks>
</member>
<member name="M:ExtCore.Collections.RangeModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},``0,``0,``2)">
 <summary></summary>
 <param name="folder"></param>
 <param name="start"></param>
 <param name="finish"></param>
 <param name="state"></param>
 <remarks></remarks>
</member>
<member name="M:ExtCore.Collections.RangeModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``1,``1,``0)">
 <summary></summary>
 <param name="folder"></param>
 <param name="start"></param>
 <param name="finish"></param>
 <param name="state"></param>
 <remarks></remarks>
</member>
<member name="M:ExtCore.Collections.RangeModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0,``0)">
 <summary></summary>
 <param name="action"></param>
 <param name="start"></param>
 <param name="finish"></param>
 <remarks></remarks>
</member>
<member name="T:ExtCore.Collections.RangeModule">
<summary>
 Functional operators over a range of values.
</summary>
</member>
<member name="M:ExtCore.Collections.MapReductionModule.FromFunctions``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,``1},``1})">
 <summary></summary>
 <param name="mapping"></param>
 <param name="reduction"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapReductionModule.FromFunctions``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}})">
 <summary></summary>
 <param name="mapping"></param>
 <param name="reduction"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapFolderModule.FromFunctions``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``2,``1},``2})">
 <summary></summary>
 <param name="mapping"></param>
 <param name="folder"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapFolderModule.FromFunctions``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary></summary>
 <param name="mapping"></param>
 <param name="folder"></param>
 <returns></returns>
</member>
<member name="F:ExtCore.Collections.SeqModule.PeekableEnumerator`1.nextElement">
<summary>
 Holds the next element from the enumerator, i.e., the element following &apos;current&apos;.
 This is necessary to avoid skipping an element when peeking.
</summary>
</member>
<member name="F:ExtCore.Collections.SeqModule.PeekableEnumerator`1.current">
<summary>
 The current element in the enumerator.
</summary>
</member>
<member name="T:ExtCore.Collections.SeqModule.PeekableEnumerator`1">
 <summary>
 Wraps an <see cref="T:System.Collections.Generic.IEnumerator`1{T}"/> to provide an additional 'peek' operation.
 </summary>
 <typeparam name="T">The type of objects to enumerate.</typeparam>
</member>
<member name="M:ExtCore.Collections.SeqModule.SegmentBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Groups consecutive elements from a sequence together into "segments".
 The specified projection function is applied to each element to produce a key;
 a new segment is started whenever an element's key is different from the previous element's key.
 </summary>
 <param name="projection"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.SegmentWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Are there any more elements in this segment?
 &lt;summary&gt;
 Groups consecutive elements from a sequence together into &quot;segments&quot;.
 The specified predicate is applied to each adjacent pair of elements in the sequence;
 a new segment is started whenever the predicate returns &apos;false&apos;.
 &lt;/summary&gt;
 &lt;param name=&quot;predicate&quot;&gt;&lt;/param&gt;
 &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
 &lt;returns&gt;&lt;/returns&gt;
 &lt;remarks&gt;This function can be thought of as a generalized form of &apos;Seq.windowed&apos;.&lt;/remarks&gt;
</summary>
</member>
<member name="M:ExtCore.Collections.SeqModule.segmentWithImpl``1(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``0,System.Boolean},ExtCore.Collections.SeqModule.PeekableEnumerator{``0})">
<summary>
 Helper function used to implement the &apos;segmentWith&apos; function.
 Given a peekable enumerator, produces one &quot;segment&quot; subsequence.
</summary>
</member>
<member name="M:ExtCore.Collections.SeqModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
 <summary>
 Applies a function to pairs of elements drawn from two sequences, threading an accumulator argument through the computation.
 If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="source1"></param>
 <param name="source2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.Sample``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Creates a new sequence by sampling a sequence at a given interval.</summary>
 <param name="interval"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.CountWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the number of elements in the sequence matching a given predicate.</summary>
 <param name="predicate"></param>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 <c>Seq.countWith predicate source = (Seq.filter predicate source |> Seq.length)</c>
 </remarks>
</member>
<member name="M:ExtCore.Collections.SeqModule.Cycle``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>
 Creates a cyclical sequence with the specified number of elements using the given generator function.
 The integer index passed to the function indicates the index of the element being generated.
 </summary>
 <param name="count"></param>
 <param name="generator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.Repeat``1(``0)">
 <summary>Generates a new sequence which returns the given value an infinite number of times.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.Replicate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Generates a new sequence which repeats the given sequence a specified number of times.</summary>
 <param name="count"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.ProjectKeys``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Applies a function to each element of the sequence, returning a new sequence whose elements are
 tuples of the original element and the function result for that element.
 </summary>
 <param name="mapping"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.ProjectValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Applies a function to each element of the sequence, returning a new sequence whose elements are
 tuples of the original element and the function result for that element.
 </summary>
 <param name="mapping"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SeqModule.AppendSingleton``1(``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>Appends an element to a sequence of elements.</summary>
 <param name="value"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.SeqModule">
<summary>
 Additional functional operators on sequences.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.ToList``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Returns a new list whose elements are the same as those in the zipper,
 and also in the same order as those in the zipper.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a new zipper on the given list.
 The created zipper will be positioned at the start of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Update``1(``0,ExtCore.Collections.ListZipper{``0})">
 <summary>
 Creates a new zipper by replacing the current list element with the given value.
 This is similar to <c>zipper.Remove().Insert(value)</c> except that when the zipper
 is empty, <c>zipper.Update(value)</c> returns an empty zipper.
 </summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Insert``1(``0,ExtCore.Collections.ListZipper{``0})">
<summary>
 Creates a new zipper by inserting the given value prior to the current list element.
 If the zipper is empty, the new zipper&apos;s list is created from the given value.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Remove``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Creates a new zipper by removing the current element from the list.
 No exception is raised if the zipper is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.MoveEnd``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Moves the zipper to the end of the list.
 No exception is raised if the zipper is already at the end of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.MoveStart``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Moves the zipper to the start of the list.
 No exception is raised if the zipper is already at the start of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.MoveNext``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Moves the zipper forwards by one step.
 No exception is raised if the zipper is already at the end of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.MoveBack``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Moves the zipper backwards by one step.
 No exception is raised if the zipper is already at the start of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Previous``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 The previous element (if any).
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Current``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 The current element (if any).
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Context``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 The previous element (if any) and current element (if any), based on the zipper&apos;s current position.
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.AtEnd``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Is the zipper positioned after the end of the list?
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.AtStart``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Is the zipper positioned prior to the start of the list?
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.IsEmpty``1(ExtCore.Collections.ListZipper{``0})">
<summary>
 Is the zipper empty?
</summary>
</member>
<member name="M:ExtCore.Collections.ListZipperModule.Empty``1">
<summary>
 The empty zipper value.
</summary>
</member>
<member name="T:ExtCore.Collections.ListZipperModule">
 <summary>Functional operators related to the <see cref="ListZipper`1"/> type.</summary>
</member>
<member name="M:ExtCore.Collections.ListModule.Distinct``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list created by keeping only the first (earliest) instance of each element.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ExactlyOne``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Extracts the only item in a single-item list.
 An <see cref="ArgumentException"/> is raised if the list is empty or contains more than one item.
 </summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Weave``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Creates a new list by combining two lists together in an alternating fashion.
 If either list is empty, the other list is returned without modification.
 </summary>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Intersperse``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Creates a new list by inserting a value between each pair of elements in a given list.
 If the specified list contains fewer than two (2) elements, the list is returned without being modified.
 </summary>
 <param name="value"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.CountWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the number of list elements matching a given predicate.</summary>
 <param name="predicate"></param>
 <param name="list"></param>
 <returns></returns>
 <remarks>
 This function is an optimized implementation of: <c>List.filter predicate list |> List.length</c>
 </remarks>
</member>
<member name="M:ExtCore.Collections.ListModule.UnzipWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Applies the given function to each element of the list and creates two (2) lists
 from the components of the returned tuple.
 </summary>
 <param name="mapping"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.UnfoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>
 Returns a list containing the elements generated by the given computation.
 The given initial state argument is passed to the element generator, which is applied
 repeatedly until a <c>None</c> value is returned.
 Each call to the element generator returns a new residual state.
 </summary>
 <param name="generator"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>
 Returns a list containing the elements generated by the given computation.
 The given initial state argument is passed to the element generator, which is applied
 repeatedly until a <c>None</c> value is returned.
 Each call to the element generator returns a new residual state.
 </summary>
 <param name="generator"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.MapPartition3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2,``3}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Splits the collection into two (3) collections, containing the elements for which the given
 function returns Choice1Of3, Choice2Of3, or Choice3Of3, respectively. This function is similar
 to List.partition, but it allows the returned collections to have different types.
 </summary>
 <param name="partitioner"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the given
 function returns Choice1Of2 or Choice2Of2, respectively. This function is similar to
 List.partition, but it allows the returned collections to have different types.
 </summary>
 <param name="partition"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.FoldBackPairwise``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>
 Applies a function to each element of the collection and the element which
 proceeds it, threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="list"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.FoldPairwise``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>
 Applies a function to each element of the collection and the element which
 follows it, threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.TakeArray``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Takes a specified number of items from a list, returning them (in an array) along with the remaining list.</summary>
 <param name="count"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Take``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Takes a specified number of items from a list, returning them (as a new list) along with the remaining list.</summary>
 <param name="count"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Choose2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>
 Applies the given function pairwise to the two lists.
 Returns the list comprised of the results <c>x</c> for each element where
 the function returns <c>Some(x)</c>.
 </summary>
 <param name="projection"></param>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ChooseIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Applies the given function to each element of the list.
 Returns the list comprised of the results <c>x</c> for each element where
 the function returns <c>Some(x)</c>. The integer index passed to the function
 indicates the index of the element being transformed.
 </summary>
 <param name="chooser"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ReverseAndMapIntoArray``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Applies the given function to each element of a list, and copies the results into an array from right-to-left so the
 produced array represents the mapped original list in reverse order.
 </summary>
 <param name="mapping"></param>
 <param name="list"></param>
 <returns></returns>
 <remarks>
 This represents an optimized version of:
 <code>
 fun mapping -> (List.map mapping) >> List.rev >> List.toArray
 </code>
 </remarks>
</member>
<member name="M:ExtCore.Collections.ListModule.ReverseIntoArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Converts a list into an array (similar to List.toArray) but copies the elements into
 the array from right-to-left, so there's no need to call List.rev before List.toArray.
 </summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ProjectKeys``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Applies a function to each element of the array, returning a new array whose elements are
 tuples of the original element and the function result for that element.
 </summary>
 <param name="projection"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ProjectValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Applies a function to each element of the array, returning a new array whose elements are
 tuples of the original element and the function result for that element.
 </summary>
 <param name="projection"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Indexed``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Creates a new list by combining each element of the list with it's index.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.DropLast``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Drops the last element of a list, returning the remaining list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Last``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element of a list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Determines if a given value is contained in a list.</summary>
 <param name="value"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ToSet``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a set that contains the same elements as the given list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.OfSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds a list that contains the elements of the set in order.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ToString(Microsoft.FSharp.Collections.FSharpList{System.Char})">
 <summary>Builds a string from the given list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.OfString(System.String)">
 <summary>Builds a list from the given string.</summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.OfOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Builds a list from the given option value.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Singleton``1(``0)">
 <summary>Create a list containing the given value.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.TryHead``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Attempt to retrieve the first element of the list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.ConsOption``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>A curried "optional-cons" operator.</summary>
 <param name="list"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ListModule.Cons``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
 <summary>A curried "cons" operator.</summary>
 <param name="list"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.ListModule">
<summary>
 Additional functional operators on immutable lists.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.UnfoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
 Returns a list containing the elements generated by the given computation.
 The given initial state argument is passed to the element generator, which is applied
 repeatedly until a None value is returned. Each call to the element generator returns
 a new residual state.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
 Returns a list containing the elements generated by the given computation.
 The given initial state argument is passed to the element generator, which is applied
 repeatedly until a None value is returned. Each call to the element generator returns
 a new residual state.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.CountWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
<summary>
 Returns the number of vector elements matching a given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.MapReduce``2(ExtCore.Collections.IMapReduction{``0,``1},ExtCore.FSharpVector{``0})">
<summary>
 Applies a mapping function to each element of the vector, then repeatedly applies
 a reduction function to each pair of results until one (1) result value remains.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.MapPartition``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2,``3}},ExtCore.FSharpVector{``0})">
<summary>
 Splits the collection into two (3) collections, containing the elements for which the given
 function returns Choice1Of3, Choice2Of3, or Choice3Of3, respectively. This function is similar
 to Array.partition, but it allows the returned collections to have different types.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},ExtCore.FSharpVector{``0})">
<summary>
 Splits the collection into two (2) collections, containing the elements for which the given
 function returns Choice1Of2 or Choice2Of2, respectively. This function is similar to
 Array.partition, but it allows the returned collections to have different types.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Split``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
<summary>
 Splits a vector into one or more vectors; the specified predicate is applied
 to each element in the vector, and whenever it returns true, that element will
 be the first element in one of the &quot;subvectors&quot;.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.FoldBackIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.FSharpVector{``0},``1)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the vector index of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.FoldIndexed``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.FSharpVector{``1})">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the vector index of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Choose2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>
 Applies the given function pairwise to the two vectors.
 Returns the vector comprised of the results <c>x</c> for each element where the function
 returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.ChooseIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.FSharpVector{``0})">
 <summary>
 Applies the given function to each element of the vector.
 Returns the vector comprised of the results <c>x</c> for each element where the function
 returns <c>Some(x)</c>. The integer index passed to the function indicates the index
 of the element being transformed.
 </summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.FindIndices``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>
 Returns a new collection containing the indices of the elements for which
 the given predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Contains``1(``0,ExtCore.FSharpVector{``0})">
<summary>
 Determines if a vector contains a specified value.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Last``1(ExtCore.FSharpVector{``0})">
<summary>
 Returns the last element in the vector.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.LastIndex``1(ExtCore.FSharpVector{``0})">
<summary>
 Returns the index of the last element in the vector.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.First``1(ExtCore.FSharpVector{``0})">
<summary>
 Returns the first element in the vector.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.ProjectKeys``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
<summary>
 Applies a function to each element of the vector, returning a new vector whose elements are
 tuples of the original element and the function result for that element.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.ProjectValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
<summary>
 Applies a function to each element of the vector, returning a new vector whose elements are
 tuples of the original element and the function result for that element.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.ToSet``1(ExtCore.FSharpVector{``0})">
<summary>
 Builds a set that contains the same elements as the given vector.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.OfSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Builds a vector that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.ZeroCreate``1(System.Int32)">
 <summary>Creates a vector where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;.</summary>
 <param name="count">The length of the vector to create.</param>
 <returns>The created vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Zip3``3(ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1},ExtCore.FSharpVector{``2})">
 <summary>Combines three vectors into an vector of triples. The three vectors must have equal lengths,
 otherwise an <c>ArgumentException</c> is raised.</summary>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <param name="vector3">The third input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>The vector of tupled elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Zip``2(ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Combines two vectors into an vector of pairs. The two vectors must have equal lengths,
 otherwise an <c>ArgumentException</c> is raised.</summary>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>The vector of tupled elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Unzip3``3(ExtCore.FSharpVector{System.Tuple{``0,``1,``2}})">
 <summary>Splits a vector of triples into three vectors.</summary>
 <param name="vec">The input vector.</param>
 <returns>The tuple of three vectors.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Unzip``2(ExtCore.FSharpVector{System.Tuple{``0,``1}})">
 <summary>Splits a vector of pairs into two vectors.</summary>
 <param name="vec">The input vector.</param>
 <returns>The two vectors.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.FSharpVector{``0})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>
 <param name="chooser">The function to transform the vector elements into options.</param>
 <param name="vec">The input vector.</param>
 <returns>The first transformed element that is <c>Some(x)</c>.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Returns the index of the first element in the vector
 that satisfies the given predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>The index of the first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>The first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.ToSeq``1(ExtCore.FSharpVector{``0})">
 <summary>Views the given vector as a sequence.</summary>
 <param name="vec">The input vector.</param>
 <returns>The sequence of vector elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.ToList``1(ExtCore.FSharpVector{``0})">
 <summary>Builds a list from the given vector.</summary>
 <param name="vec">The input vector.</param>
 <returns>The list of vector elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the vector.</summary>
 <param name="projection">The function to transform the vector elements into the type to be summed.</param>
 <param name="vec">The input vector.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Sum``1(ExtCore.FSharpVector{``0})">
 <summary>Returns the sum of the elements in the vector.</summary>
 <param name="vec">The input vector.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},ExtCore.FSharpVector{``0})">
 <summary>Sorts the elements of a vector, using the given comparison function as the order, returning a new vector.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="comparer">The function to compare pairs of vector elements.</param>
 <param name="vec">The input vector.</param>
 <returns>The sorted vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Sorts the elements of a vector, using the given projection for the keys and returning a new vector. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform vector elements into the type that is compared.</param>
 <param name="vec">The input vector.</param>
 <returns>The sorted vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Sort``1(ExtCore.FSharpVector{``0})">
 <summary>Sorts the elements of a vector, returning a new vector. Elements are compared using Operators.compare. </summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="vec">The input vector.</param>
 <returns>The sorted vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.GetSubVector``1(ExtCore.FSharpVector{``0},System.Int32,System.Int32)">
 <summary>Builds a new vector that contains the given subrange specified by
 starting index and length.</summary>
 <param name="vec">The input vector.</param>
 <param name="startIndex">The index of the first element of the sub vector.</param>
 <param name="count">The length of the sub vector.</param>
 <returns>The created sub vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},ExtCore.FSharpVector{``0},``1)">
 <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="vec">The input vector.</param>
 <param name="state">The initial state.</param>
 <returns>The vector of state values.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,ExtCore.FSharpVector{``1})">
 <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="vec">The input vector.</param>
 <returns>The vector of state values.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Reverse``1(ExtCore.FSharpVector{``0})">
 <summary>Returns a new vector with the elements in reverse order.</summary>
 <param name="vec">The input vector.</param>
 <returns>The reversed vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.FSharpVector{``0})">
 <summary>Applies a function to each element of the vector, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.
 Raises ArgumentException if the vector has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vector is empty.</exception>
 <returns>The final result of the reductions.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.FSharpVector{``0})">
 <summary>Applies a function to each element of the vector, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the vector has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vector is empty.</exception>
 <returns>The final result of the redcutions.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.FSharpVector{``0})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>
 <returns>The first result.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},ExtCore.FSharpVector{``0})">
 <summary>Returns a vector with all elements permuted according to the
 specified permutation.</summary>
 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="vec">The input vector.</param>
 <returns>The output vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>A pair of vectors. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new vector from the given enumerable object.</summary>
 <param name="source">The input sequence.</param>
 <returns>The vector of elements from the sequence.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a vector from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>The vector of elements from the list.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Returns the lowest of all elements of the vector, compared via Operators.min on the function result.</summary>

 <remarks>Throws ArgumentException for empty vectors.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vector is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Min``1(ExtCore.FSharpVector{``0})">
 <summary>Returns the lowest of all elements of the vector, compared via Operators.min.</summary>

 <remarks>Throws ArgumentException for empty vectors</remarks>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vector is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Returns the greatest of all elements of the vector, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty vectors.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vector is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Max``1(ExtCore.FSharpVector{``0})">
 <summary>Returns the greatest of all elements of the vector, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty vectors.</remarks>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vector is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements. The two input vectors must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="mapping">The function to transform pairs of input elements and their indices.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>The vector of transformed elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},ExtCore.FSharpVector{``0})">
 <summary>Builds a new vector whose elements are the results of applying the given function
 to each of the elements of the vector. The integer index passed to the
 function indicates the index of element being transformed.</summary>
 <param name="mapping">The function to transform elements and their indices.</param>
 <param name="vec">The input vector.</param>
 <returns>The vector of transformed elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 vectors must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="mapping">The function to transform the pairs of the input elements.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>The vector of transformed elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Builds a new vector whose elements are the results of applying the given function
 to each of the elements of the vector.</summary>
 <param name="mapping">The function to transform elements of the vector.</param>
 <param name="vec">The input vector.</param>
 <returns>The vector of transformed elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Applies the given function to pair of elements drawn from matching indices in two vectors,
 also passing the index of the elements. The two vectors must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.</summary>
 <param name="action">The function to apply to each index and pair of elements.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
</member>
<member name="M:ExtCore.Collections.VectorModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.FSharpVector{``0})">
 <summary>Applies the given function to each element of the vector. The integer passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to each index and element.</param>
 <param name="vec">The input vector.</param>
</member>
<member name="M:ExtCore.Collections.VectorModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Applies the given function to pair of elements drawn from matching indices in two vectors. The
 two vectors must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="action">The function to apply.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
</member>
<member name="M:ExtCore.Collections.VectorModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.FSharpVector{``0})">
 <summary>Applies the given function to each element of the vector.</summary>
 <param name="action">The function to apply.</param>
 <param name="vec">The input vector.</param>
</member>
<member name="M:ExtCore.Collections.VectorModule.Init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Creates a vector given the dimension and a generator function to compute the elements.</summary>
 <param name="count">The number of elements to initialize.</param>
 <param name="initializer">The function to generate the initial values for each index.</param>
 <returns>The created vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Get``1(ExtCore.FSharpVector{``0},System.Int32)">
 <summary>Gets an element from a vector.</summary>
 <param name="vec">The input vector.</param>
 <param name="index">The input index.</param>
 <returns>The value of the vector at the given index.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1},``2)">
 <summary>Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation. The two input
 vectors must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <param name="state">The initial state.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>The final state.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},ExtCore.FSharpVector{``0},``1)">
 <summary>Applies a function to each element of the vector, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="vec">The input vector.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,ExtCore.FSharpVector{``1},ExtCore.FSharpVector{``2})">
 <summary>Applies a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation. The two input
 vectors must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>The final state.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,ExtCore.FSharpVector{``1})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="vec">The input vector.</param>
 <returns>The final state.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Tests if all corresponding elements of the vector satisfy the given predicate pairwise.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <exception cref="System.ArgumentException">Thrown when the input vectors differ in length.</exception>
 <returns>True if all of the vector elements satisfy the predicate.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Tests if all elements of the vector satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>True if all of the vector elements satisfy the predicate.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Returns the index of the first element in the vector
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The index of the first element in the vector that satisfies the given predicate.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Returns the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The first element for which <c>predicate</c> returns true.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>An vector containing the elements for which the given predicate returns true.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Fill``1(ExtCore.FSharpVector{``0},System.Int32,System.Int32,``0)">
 <summary>Fills a range of elements of the vector with the given value.</summary>
 <param name="target">The target vector.</param>
 <param name="targetIndex">The index of the first element to set.</param>
 <param name="count">The number of elements to set.</param>
 <param name="value">The value to set.</param>
 <returns>A new vector created by copying the target vector, then overwriting the specified
 range of values with <paramref name="value"/>.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``1})">
 <summary>Tests if any pair of corresponding elements of the vectors satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <returns>True if any result from <c>predicate</c> is true.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Tests if any element of the vector satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input vector. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>True if any result from <c>predicate</c> is true.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Create``1(System.Int32,``0)">
 <summary>Creates a vector whose elements are all initially the given value.</summary>
 <param name="count">The length of the vector to create.</param>
 <param name="value">The value for the elements.</param>
 <returns>The created vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Copy``1(ExtCore.FSharpVector{``0})">
 <summary>Builds a new vector that contains the elements of the given vector.</summary>
 <param name="vec">The input vector.</param>
 <returns>A copy of the input vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Concat``1(System.Collections.Generic.IEnumerable{ExtCore.FSharpVector{``0}})">
 <summary>Builds a new vector that contains the elements of each of the given sequence of vectors.</summary>
 <param name="vectors">The input sequence of vectors.</param>
 <returns>The concatenation of the sequence of input vectors.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,ExtCore.FSharpVector{``1}},ExtCore.FSharpVector{``0})">
 <summary>For each element of the vector, applies the given function. Concatenates all the results and return the combined vector.</summary>
 <param name="mapping">The function to create sub-vectors from the input vector elements.</param>
 <param name="vec">The input vector.</param>
 <returns>The concatenation of the sub-vectors.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.FSharpVector{``0})">
 <summary>Applies the given function to each element of the vector. Returns
 the vector comprised of the results "x" for each element where
 the function returns Some(x)</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="vec">The input vector.</param>
 <returns>The vector of results.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.CopyTo``1(ExtCore.FSharpVector{``0},System.Int32,ExtCore.FSharpVector{``0},System.Int32,System.Int32)">
 <summary>Reads a range of elements from the first vector and write them into the second.</summary>
 <param name="source">The source vector.</param>
 <param name="sourceIndex">The starting index of the source vector.</param>
 <param name="target">The target vector.</param>
 <param name="targetIndex">The starting index of the target vector.</param>
 <param name="count">The number of elements to copy.</param>
 <returns>A new vector created by copying the target vector, then overwriting the specified
 range of elements with the elements from the source vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Returns the average of the elements generated by applying the function to each element of the vector.</summary>
 <param name="projection">The function to transform the vector elements before averaging.</param>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when <c>vector</c> is empty.</exception>
 <returns>The computed average.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Average``1(ExtCore.FSharpVector{``0})">
 <summary>Returns the average of the elements in the vector.</summary>
 <param name="vec">The input vector.</param>
 <exception cref="System.ArgumentException">Thrown when <paramref name="vec"/> is empty.</exception>
 <returns>The average of the elements in the vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Append``1(ExtCore.FSharpVector{``0},ExtCore.FSharpVector{``0})">
 <summary>Builds a new vector that contains the elements of the first vector followed by the elements of the second vector.</summary>
 <param name="vector1">The first input vector.</param>
 <param name="vector2">The second input vector.</param>
 <returns>The resulting vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Singleton``1(``0)">
<summary>
 Given an element, creates a vector containing just that element.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.IsEmpty``1(ExtCore.FSharpVector{``0})">
 <summary>Returns true if the given vector is empty, otherwise false.</summary>
 <param name="vec">The input vector.</param>
 <returns>True if the vector is empty.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Length``1(ExtCore.FSharpVector{``0})">
 <summary>Returns the length of a vector. You can also use property vec.Length.</summary>
 <param name="vec">The input vector.</param>
 <returns>The length of the vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.OfArray``1(``0[])">
<summary>
 Builds a vector from the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Empty``1">
<summary>
 Returns an empty vector of the given type.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.elements``1(ExtCore.FSharpVector{``0})">
<summary>
 Returns the underlying array for a vector.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.CheckInitialized``1(System.String,ExtCore.FSharpVector{``0})">
<summary>
 Checks if the vector has been initialized; if not, an ArgumentNullException is raised.
</summary>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.FSharpVector{``0})">
 <summary>Split the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to indicies is not specified.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="vec">The input vector.</param>
 <returns>A pair of vectors. The first containing the elements the predicate evaluated
 to true, and the second containing those evaluated to false.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},ExtCore.FSharpVector{``0})">
 <summary>Build a new vector whose elements are the results of applying the given function
 to each of the elements of the vector. The integer index passed to the
 function indicates the index of element being transformed.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input vector is not specified.</remarks>
 <param name="mapping"></param>
 <param name="vec">The input vector.</param>
 <returns>The vector of transformed elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.FSharpVector{``0})">
 <summary>Build a new vector whose elements are the results of applying the given function
 to each of the elements of the vector.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input vector is not specified.</remarks>
 <param name="mapping"></param>
 <param name="vec">The input vector.</param>
 <returns>The vector of transformed elements.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Create a vector given the dimension and a generator function to compute the elements.</summary>
 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to indicies is not specified.</remarks>
 <param name="count"></param>
 <param name="initializer"></param>
 <returns>The created vector.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.FSharpVector{``0})">
 <summary>Apply the given function to each element of the vector. The integer passed to the
 function indicates the index of element.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input vector is not specified.</remarks>
 <param name="action"></param>
 <param name="vec">The input vector.</param>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.FSharpVector{``0})">
 <summary>Apply the given function to each element of the vector. </summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input vector is not specified.</remarks>
 <param name="action"></param>
 <param name="vec">The input vector.</param>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,ExtCore.FSharpVector{``1}},ExtCore.FSharpVector{``0})">
 <summary>For each element of the vector, apply the given function. Concatenate all the results and return the combined vector.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input vector is not specified.</remarks>
 <param name="mapping"></param>
 <param name="vec">The input vector.</param>
 <returns>The concatenation of the sub-vectors.</returns>
</member>
<member name="M:ExtCore.Collections.VectorModule.Parallel.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.FSharpVector{``0})">
 <summary>Apply the given function to each element of the vector. Return
 the vector comprised of the results "x" for each element where
 the function returns Some(x).</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input vector is not specified.</remarks>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="vec">The input vector.</param>
 <returns>The vector of results.</returns>
</member>
<member name="T:ExtCore.Collections.VectorModule.Parallel">
<summary>
 Provides parallel operations on vectors.
</summary>
</member>
<member name="T:ExtCore.Collections.VectorModule">
<summary>
 Functional operators related to vectors (immutable arrays).
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
 <summary>Returns the average of the elements generated by applying the function to each element of the ResizeArray.</summary>
 <param name="projection">The function to transform the ResizeArray elements before averaging.</param>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The computed average.</returns>
 <exception cref="System.ArgumentException">Thrown when <paramref name="resizeArray"/> is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Average``1(System.Collections.Generic.List{``0})">
 <summary>Returns the average of the elements in the ResizeArray.</summary>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The average of the elements in the ResizeArray.</returns>
 <exception cref="System.ArgumentException">Thrown when <paramref name="resizeArray"/> is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
 <summary>Returns the greatest of all elements of the ResizeArray, compared via Operators.max on the function result.</summary>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The maximum element.</returns>
 <exception cref="System.ArgumentException">Thrown when <paramref name="resizeArray"/> is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Max``1(System.Collections.Generic.List{``0})">
 <summary>Returns the greatest of all elements of the ResizeArray, compared via Operators.max on the function result.</summary>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The maximum element.</returns>
 <exception cref="System.ArgumentException">Thrown when <paramref name="resizeArray"/> is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
 <summary>Returns the lowest of all elements of the ResizeArray, compared via Operators.min on the function result.</summary>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The minimum element.</returns>
 <exception cref="System.ArgumentException">Thrown when <paramref name="resizeArray"/> is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Min``1(System.Collections.Generic.List{``0})">
 <summary>Returns the lowest of all elements of the ResizeArray, compared via Operators.min.</summary>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The minimum element.</returns>
 <exception cref="System.ArgumentException">Thrown when <paramref name="resizeArray"/> is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the ResizeArray.</summary>
 <param name="projection">The function to transform the ResizeArray elements into the type to be summed.</param>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Sum``1(System.Collections.Generic.List{``0})">
 <summary>Returns the sum of the elements in the ResizeArray.</summary>
 <param name="resizeArray">The input ResizeArray.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},System.Collections.Generic.List{``0})">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the
 given function returns <c>Choice1Of2</c> or <c>Choice2Of2</c>, respectively. This function is similar to
 <c>ResizeArray.partition</c>, but it allows the returned collections to have different element types.
 </summary>
 <param name="partitioner"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
 <summary>
 Split the collection into two collections, containing the elements for which
 the given predicate returns <c>true</c> and <c>false</c> respectively.
 </summary>
 <param name="predicate"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
 <summary>
 Like <c>foldBack</c>, but return both the intermediary and final results.
 </summary>
 <param name="folder"></param>
 <param name="resizeArray"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ScanBackSub``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},System.Int32,System.Int32,``1)">
 <summary></summary>
 <param name="folder"></param>
 <param name="resizeArray"></param>
 <param name="startIndex"></param>
 <param name="endIndex"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
 <summary>
 Like <c>fold</c>, but return the intermediary and final results.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ScanSub``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1},System.Int32,System.Int32)">
 <summary></summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="resizeArray"></param>
 <param name="startIndex"></param>
 <param name="endIndex"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
 <summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f i0 (...(f iN-1 iN))</c>.
 Raises <c>ArgumentException</c> if the array has size zero.
 </summary>
 <param name="reduction"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
 <summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises <c>ArgumentException</c> if the array has size zero.
 <summary>
 <param name="reduction"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
 <summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is raised.
 </summary>
 <param name="folder"></param>
 <param name="resizeArray1"></param>
 <param name="resizeArray2"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FoldBackIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},System.Collections.Generic.List{``0},``1)">
 <summary></summary>
 <param name="folder"></param>
 <param name="resizeArray"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FoldBackSub``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},System.Int32,System.Int32,``1)">
 <summary></summary>
 <param name="folder"></param>
 <param name="resizeArray"></param>
 <param name="startIndex"></param>
 <param name="endIndex"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
 <summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are
 <c>i0...iN</c> then computes <c>f i0 (...(f iN s))</c>.
 </summary>
 <param name="folder"></param>
 <param name="resizeArray"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
 <summary>
 Apply a function to pairs of elements drawn from the two collections, left-to-right,
 threading an accumulator argument through the computation.  The two input arrays must
 have the same lengths, otherwise an <c>ArgumentException</c> is raised.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="resizeArray1"></param>
 <param name="resizeArray2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FoldIndexed``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,System.Collections.Generic.List{``1})">
 <summary>
 Applies a function to each element of the collection, threading an accumulator argument
 through the computation. The integer index passed to the function indicates the
 index of the element within the collection.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FoldSub``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1},System.Int32,System.Int32)">
 <summary></summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="resizeArray"></param>
 <param name="startIndex"></param>
 <param name="endIndex"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
 <summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f s i0)...) iN</c>.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
 <summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is raised.
 </summary>
 <summary></summary>
 <param name="mapping"></param>
 <param name="resizeArray1"></param>
 <param name="resizeArray2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
 <summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 arrays must have the same lengths.
 </summary>
 <param name="mapping"></param>
 <param name="resizeArray1"></param>
 <param name="resizeArray2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
 <summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.
 </summary>
 <param name="mapping"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
 <summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.
 </summary>
 <param name="mapping"></param>
 <param name="resizeArray"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
 <summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Iterate2``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
 <summary>
 Apply the given function to two arrays simultaneously. The two arrays
 must have the same lengths, otherwise an <c>ArgumentException</c> is raised.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
 <summary>
 Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If the function
 never returns <c>Some(x)</c>, raises KeyNotFoundException.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
 <summary>
 Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If the function
 never returns <c>Some(x)</c>, returns <c>None</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FindIndexIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
 <summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisfy the predicate.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.TryFindIndexIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
 <summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisfy the predicate.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
 <summary>
 Return the first element for which the given function returns <c>true</c>.
 Raise <c>KeyNotFoundException</c> if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
 <summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
 <summary>
 Apply the given function to each element of the array. Return
 the array comprised of the results "x" for each element where
 the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &lt;c&gt;true&lt;/c&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split a ResizeArray of pairs into two ResizeArrays.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two ResizeArrays into a ResizeArray of pairs.
 The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first ResizeArray and write them into the second.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Rev``1(System.Collections.Generic.List{``0})">
<summary>
 Return a new ResizeArray with the elements in reverse order.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
 Fill a range of the collection with the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Build a new ResizeArray that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
 Build a new ResizeArray that contains the elements of the first ResizeArray followed by
 the elements of the second ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.List{``0}})">
<summary>
 Build a new ResizeArray that contains the elements of each of the given sequence of ResizeArrays.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Singleton``1(``0)">
<summary>
 Return an array containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Copy``1(System.Collections.Generic.List{``0})">
<summary>
 Build a new ResizeArray that contains the elements of the given ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.SortInPlace``1(System.Collections.Generic.List{``0})">
<summary>
 Sorts the elements of the ResizeArray by mutating the ResizeArray in-place.
 Elements are compared using Operators.compare.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ToVector``1(System.Collections.Generic.List{``0})">
<summary>
 Build a vector from the given ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ToArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ToList``1(System.Collections.Generic.List{``0})">
<summary>
 Build a list from the given ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.ToSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the ResizeArray as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.OfVector``1(ExtCore.FSharpVector{``0})">
<summary>
 Build a ResizeArray from the given vector.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.OfArray``1(``0[])">
<summary>
 Build a ResizeArray from the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build a ResizeArray from the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a ResizeArray from the given sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Contains``1(``0,System.Collections.Generic.List{``0})">
<summary>
 Determines whether an element is in the ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Add``1(``0,System.Collections.Generic.List{``0})">
<summary>
 Adds an object to the end of the ResizeArray.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create a ResizeArray by calling the given generator on each index.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Create``1(System.Int32,``0)">
<summary>
 Create a ResizeArray whose elements are all initially the given value.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.IsEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return true if the given array is empty, otherwise false.
</summary>
</member>
<member name="M:ExtCore.Collections.ResizeArrayModule.Length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.
</summary>
</member>
<member name="T:ExtCore.Collections.ResizeArrayModule">
 <summary>
 Functional operators related to the System.Collections.Generic.List&lt;T&gt; type (called ResizeArray in F#).
 </summary>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Initialize2``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Tuple{``0,``1}})">
 <summary>
 
 </summary>
 <param name="length"></param>
 <param name="generator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.UnfoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>
 Returns a list containing the elements generated by the given computation.
 The given initial state argument is passed to the element generator, which is applied
 repeatedly until a <c>None</c> value is returned. Each call to the element generator returns
 a new residual state.
 </summary>
 <param name="generator"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>
 Returns a list containing the elements generated by the given computation.
 The given initial state argument is passed to the element generator, which is applied repeatedly until a <c>None</c> value
 is returned. Each call to the element generator returns a new residual state.
 </summary>
 <param name="generator"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FoldBackPairwise``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},``0[],``1)">
 <summary>
 Applies a function to each character in the string and the character which
 proceeds it, threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="array"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FoldPairwise``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``1[])">
 <summary>
 Applies a function to each character in the string and the character which
 follows it, threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.CountWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the number of array elements matching a given predicate.</summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
 <remarks><c>Array.countWith predicate array = (Array.filter predicate array |> Array.length)</c></remarks>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ChooseIndexedInPlace``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},``0[])">
 <summary></summary>
 <param name="chooser"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ChooseInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}},``0[])">
 <summary></summary>
 <param name="chooser"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.MapIndexedInPlace``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary></summary>
 <param name="mapping"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.MapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
 <summary></summary>
 <param name="mapping"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.MapReduce``2(ExtCore.Collections.IMapReduction{``0,``1},``0[])">
 <summary>
 Applies a mapping function to each element of the array, then repeatedly applies
 a reduction function to each pair of results until one (1) result value remains.
 </summary>
 <param name="mapReduction"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.MapPartition3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2,``3}},``0[])">
 <summary>
 Splits the collection into three (3) collections, containing the elements for which the given
 function returns <c>Choice1Of3</c>, <c>Choice2Of3</c>, or <c>Choice3Of3</c>, respectively.
 </summary>
 <param name="partitioner"></param>
 <param name="array"></param>
 <returns></returns>
 <remarks>
 This function is similar to Array.partition, but it allows the returned collections to have different types.
 </remarks>
</member>
<member name="M:ExtCore.Collections.ArrayModule.MapPartitionIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0[])">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the given function returns
 <c>Choice1Of2</c> or <c>Choice2Of2</c>, respectively.
 The index passed to the function indicates the index of the element.
 </summary>
 <param name="partitioner"></param>
 <param name="array"></param>
 <returns></returns>
 <remarks>
 This function is similar to Array.partition, but it allows the returned collections to have different types.
 </remarks>
</member>
<member name="M:ExtCore.Collections.ArrayModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},``0[])">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the given function returns
 <c>Choice1Of2</c> or <c>Choice2Of2</c>, respectively.
 </summary>
 <param name="partitioner"></param>
 <param name="array"></param>
 <returns></returns>
 <remarks>
 This function is similar to Array.partition, but it allows the returned collections to have different types.
 </remarks>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Segment2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])">
 <summary>
 Splits two arrays into one or more segments by applying the specified predicate to the each pair of array elements and
 starting a new view whenever the predicate returns <c>true</c>.
 </summary>
 <param name="predicate"></param>
 <param name="array1"></param>
 <param name="array2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Segment``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>
 Splits an array into one or more segments by applying the specified predicate to each element of the array and starting
 a new view at each element where the predicate returns <c>true</c>.
 </summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Split``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>
 Splits an array into one or more arrays; the specified predicate is applied to each element in the array, and whenever it
 returns <c>true</c>, that element will be the first element in one of the "subarrays".
 </summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FoldBackIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},``0[],``1)">
 <summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
 </summary>
 <param name="folder"></param>
 <param name="array"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FoldIndexed``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``1[])">
 <summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Choose2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},``0[],``1[])">
 <summary>
 Applies the given function pairwise to the two arrays.
 Returns the array comprised of the results <c>x</c> for each element where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser"></param>
 <param name="array1"></param>
 <param name="array2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ChooseIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
 <summary>
 Applies the given function to each element of the array.
 Returns the array comprised of the results <c>x</c> for each element where the function returns <c>Some(x)</c>.
 The integer index passed to the function indicates the index of the element being transformed.
 </summary>
 <param name="chooser"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FindIndices``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>
 Returns a new collection containing the indices of the elements for which the given predicate returns <c>true</c>.
 </summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.PickBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary></summary>
 <param name="picker"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.TryPickBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary></summary>
 <param name="picker"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary></summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary></summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary></summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary></summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ExpandLeft``1(System.Int32,``0[])">
 <summary>Expands an array by creating a copy of it which has the specified number of empty elements prepended to it.</summary>
 <param name="count"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ExpandRight``1(System.Int32,``0[])">
 <summary>Expands an array by creating a copy of it which has the specified number of empty elements appended to it.</summary>
 <param name="count"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Contains``1(``0,``0[])">
 <summary>Determines if an array contains a specified value.</summary>
 <param name="value"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Clear``1(``0[])">
 <summary>Sets all elements in the array to Unchecked.defaultof.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Last``1(``0[])">
 <summary>Returns the last element in the array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.LastIndex``1(``0[])">
 <summary>Returns the index of the last element in the array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.First``1(``0[])">
 <summary>Returns the first element in the array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ProjectKeys``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>
 Applies a function to each element of the array, returning a new array whose elements are
 tuples of the original element and the function result for that element.
 </summary>
 <param name="projection"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ProjectValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>
 Applies a function to each element of the array, returning a new array whose elements are
 tuples of the original element and the function result for that element.
 </summary>
 <param name="projection"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ToVector``1(``0[])">
 <summary>Builds a vector from the given array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ToSet``1(``0[])">
 <summary>Builds a set that contains the same elements as the given array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.OfSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds an array that contains the elements of the set in order.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.ExactlyOne``1(``0[])">
 <summary>Returns the only element of the array.</summary>
 <param name="array">The input array.</param>
 <returns>The only element of the array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input array does not have precisely one element.</exception>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Singleton``1(``0)">
 <summary>Given an element, creates an array containing just that element.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.RawLength``1(``0[])">
 <summary>Returns the length of the array as an unsigned, native-length integer.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="F:ExtCore.Collections.ArrayModule.Parallel.LastElementComparer`1.instance">
<summary>
 The single instance of this type.
</summary>
</member>
<member name="P:ExtCore.Collections.ArrayModule.Parallel.LastElementComparer`1.Instance">
<summary>
 The single instance of the LastElementComparer`1 type.
</summary>
</member>
<member name="F:ExtCore.Collections.ArrayModule.Parallel.ElementIndexComparer`1.instance">
<summary>
 The single instance of this type.
</summary>
</member>
<member name="P:ExtCore.Collections.ArrayModule.Parallel.ElementIndexComparer`1.Instance">
<summary>
 The single instance of the ElementIndexComparer`1 type.
</summary>
</member>
<member name="T:ExtCore.Collections.ArrayModule.Parallel.ElementIndexComparer`1">
<summary>
 Sorts key-value pairs with integer keys according to the value of the key.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the sum of the results generated by applying the function to each element of the array.</summary>
 <param name="projection">The function to transform the array elements into the type to be summed.</param>
 <param name="array">The input array.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Sum``1(``0[])">
 <summary>Returns the sum of the elements in the array.</summary>
 <param name="array">The input array.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the least of all elements of the array, compared via Operators.min on the function result.</summary>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>
 <returns>The minimum element.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Min``1(``0[])">
 <summary>Returns the least of all elements of the array, compared via Operators.min on the function result.</summary>
 <param name="array">The input array.</param>
 <returns>The minimum element.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>
 <returns>The maximum element.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Max``1(``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>
 <param name="array">The input array.</param>
 <returns>The maximum element.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MapPartitionIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0[])">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the given function returns
 <c>Choice1Of2</c> or <c>Choice2Of2</c>, respectively.
 The index passed to the function indicates the index of the element.
 </summary>
 <param name="partitioner"></param>
 <param name="array"></param>
 <returns></returns>
 <remarks>
 This function is similar to Array.partition, but it allows the returned collections to have different types.
 </remarks>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},``0[])">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the given function returns
 <c>Choice1Of2</c> or <c>Choice2Of2</c>, respectively.
 </summary>
 <param name="partitioner"></param>
 <param name="array"></param>
 <returns></returns>
 <remarks>
 This function is similar to Array.partition, but it allows the returned collections to have different types.
 </remarks>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.ChooseIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
 <summary>
 
 </summary>
 <param name="chooser"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Choose2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},``0[],``1[])">
 <summary>
 Applies the given function pairwise to the two arrays.
 Returns the array comprised of the results <c>x</c> for each element where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser"></param>
 <param name="array1"></param>
 <param name="array2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>An array containing the elements for which the given predicate returns true.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MapReduce``2(ExtCore.Collections.IMapReduction{``0,``1},``0[])">
 <summary>
 Applies a mapping function to each element of the array, then repeatedly applies
 a reduction function to each pair of results until one (1) result value remains.
 </summary>
 <param name="mapReduction"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentNullException">Thrown when <paramref name="array"/> is null.</exception>
 <exception cref="System.ArgumentException">Thrown when <paramref name="array"/> is empty.</exception>
 <returns>The final result of the reductions.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.CountWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary></summary>
 <param name="predicate"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MapIndexedInPlace``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary></summary>
 <param name="mapping"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.MapInPlace``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0[])">
 <summary></summary>
 <param name="mapping"></param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.Initialize2``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Tuple{``0,``1}})">
 <summary>
 
 </summary>
 <param name="length"></param>
 <param name="generator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.ArrayModule.Parallel.combineWorkerResults``1(System.Collections.Generic.List{System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.Int32,``0}}})">
 <summary>
 Combines the results of individual workers (e.g., threads, tasks), according to the ordering
 of elements in the original input array.
 </summary>
 <param name="workerResults"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.ArrayModule.Parallel">
<summary>
 Provides additional parallel operations on arrays.
</summary>
</member>
<member name="T:ExtCore.Collections.ArrayModule">
<summary>
 Additional functional operators on arrays.
</summary>
</member>
<member name="M:ExtCore.Collections.TaggedArrayModule.FoldBackIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},``0[],``1)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
 The index values are tagged with a unit-of-measure type before applying them to the folder function.
</summary>
</member>
<member name="M:ExtCore.Collections.TaggedArrayModule.FoldIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``1[])">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
 The index values are tagged with a unit-of-measure type before applying them to the folder function.
</summary>
</member>
<member name="M:ExtCore.Collections.TaggedArrayModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0[],``1[])">
<summary>
 Similar to Array.mapi, but &apos;tags&apos; the index values with a unit-of-measure
 type before applying them to the mapping function.
</summary>
</member>
<member name="M:ExtCore.Collections.TaggedArrayModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])">
<summary>
 Similar to Array.mapi, but &apos;tags&apos; the index values with a unit-of-measure
 type before applying them to the mapping function.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.ArraySegment{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the ArrayView.</summary>
 <param name="projection">The function to transform the ArrayView elements into the type to be summed.</param>
 <param name="view">The input ArrayView.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Sum``1(System.ArraySegment{``0})">
 <summary>Returns the sum of the elements in the ArrayView.</summary>
 <param name="view">The input ArrayView.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.ArraySegment{``0})">
 <summary>Returns the greatest of all elements of the ArrayView, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty ArrayViews.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="view">The input ArrayView.</param>
 <exception cref="System.ArgumentException">Thrown when the input ArrayView is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.ArraySegment{``0})">
 <summary>Returns the average of the elements generated by applying the function to each element of the ArrayView.</summary>
 <param name="projection">The function to transform the ArrayView elements before averaging.</param>
 <param name="view">The input ArrayView.</param>
 <exception cref="System.ArgumentException">Thrown when <c>view</c> is empty.</exception>
 <returns>The computed average.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Average``1(System.ArraySegment{``0})">
 <summary>Returns the average of the elements in the ArrayView.</summary>
 <param name="view">The input ArrayView.</param>
 <exception cref="System.ArgumentException">Thrown when <paramref name="view"/> is empty.</exception>
 <returns>The average of the elements in the ArrayView.</returns>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.ToArray``1(System.ArraySegment{``0})">
<summary>
 Builds a new array from the elements within the ArrayView&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Clear``1(System.ArraySegment{``0})">
<summary>
 Sets the elements in the ArrayView&lt;&apos;T&gt; to Unchecked.defaultof.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Last``1(System.ArraySegment{``0})">
<summary>
 Gets the last element in an ArrayView&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.LastIndex``1(System.ArraySegment{``0})">
<summary>
 Gets the index of the last element in an ArrayView&lt;&apos;T&gt;, within the original array.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.LastIndexUnsafe``1(System.ArraySegment{``0})">
<summary>
 Gets the index of the last element in an ArrayView&lt;&apos;T&gt;, within the original array.
 NOTE : This implemention is meant for internal use only, and does NOT perform bounds checking.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.First``1(System.ArraySegment{``0})">
<summary>
 Gets the first element in an ArrayView&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Set``1(System.ArraySegment{``0},System.Int32,``0)">
<summary>
 Sets an element of an ArrayView&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Get``1(System.ArraySegment{``0},System.Int32)">
<summary>
 Gets an element of an ArrayView&lt;&apos;T&gt;.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.create``1(``0[],System.Int32,System.Int32)">
<summary>
 Creates an ArrayView on an array, starting at the specified index.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.OfArray``1(``0[])">
<summary>
 Creates an ArrayView spanning the entire length of an array.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.IsEmpty``1(System.ArraySegment{``0})">
<summary>
 Is the ArrayView empty?
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Offset``1(System.ArraySegment{``0})">
<summary>
 Returns the index in the underlying array at which the ArrayView begins.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Count``1(System.ArraySegment{``0})">
<summary>
 Returns the number of elements in the given ArrayView.
 You can also use the property view.Count.
</summary>
</member>
<member name="M:ExtCore.Collections.ArrayViewModule.Array``1(System.ArraySegment{``0})">
<summary>
 Returns the underlying array for the given ArrayView.
</summary>
</member>
<member name="T:ExtCore.Collections.ArrayViewModule">
<summary>
 Functional operators on ArrayViews.
</summary>
</member>
<member name="M:ExtCore.Collections.SetModule.CountWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the number of set elements matching a given predicate.</summary>
 <param name="predicate"></param>
 <param name="set"></param>
 <returns></returns>
 <remarks><c>Set.countWith predicate set = (Set.filter predicate set |> Set.count)</c></remarks>
</member>
<member name="M:ExtCore.Collections.SetModule.Disjoint``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Determines if two sets are disjoint, i.e., whether they have no elements in common.</summary>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Condense``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpSet{``1}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 For each element of the set, applies the given function to produce a set of results.
 Computes the intersection of all result sets and returns the combined set.
 </summary>
 <param name="mapping"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpSet{``1}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 For each element of the set, applies the given function to produce a set of results.
 Computes the union of all result sets and returns the combined set.
 </summary>
 <param name="mapping"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Cartesian``2(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``1})">
 <summary>The Cartesian product of two sets.</summary>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.SymmetricDifference``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Computes the symmetric difference of two sets; that is, the set of elements which are in either
 of the sets and not in their intersection.
 </summary>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
 <remarks>
 The symmetric difference is similar to the XOR ("exclusive-or") operation, except that
 XOR returns 'true' when an element is not in both sets. This requires the "universe"
 (set of all possible domain elements) to be known. The symmetric difference operation
 does not have this requirement and so can be used when the universe is not known or infinite.
 </remarks>
</member>
<member name="M:ExtCore.Collections.SetModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Splits the collection into two (2) collections, containing the elements for which the given function returns
 <c>Choice1Of2</c> or <c>Choice2Of2</c>, respectively.
 </summary>
 <param name="partitioner"></param>
 <param name="set"></param>
 <returns></returns>
 <remarks>
 This function is similar to Set.partition, but it allows the returned collections to have different types.
 </remarks>
</member>
<member name="M:ExtCore.Collections.SetModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Returns the first (least) element for which the given predicate returns <c>true</c>.
 Raises <see cref="KeyNotFoundException"/> if no such element exists.
 </summary>
 <param name="predicate"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Returns the first (least) element for which the given predicate returns <c>true</c>.
 Returns <c>None</c> if no such element exists.
 </summary>
 <param name="predicate"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Applies the given function to each element of the set, returning the first result where the function returns <c>Some(x)</c>.
 If the function never returns <c>Some(x)</c> then a <see cref="KeyNotFoundException"/> is raised.
 </summary>
 <param name="picker"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Applies the given function to each element of the set, returning the first result where the function returns <c>Some(x)</c>.
 If the function never returns <c>Some(x)</c> then <c>None</c> is returned.
 </summary>
 <param name="picker"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Applies the given function to each element of the set.
 Returns the set comprised of the results <c>x</c> for each element where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Reduces elements in a set in order from the greatest (maximum) element to the least (minimum) element.</summary>
 <param name="reduction"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Reduces elements in a set in order from the least (minimum) element to the greatest (maximum) element.</summary>
 <param name="reduction"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.ExtractMaximum``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Extracts the maximum element from a set, returning the element along with the updated set.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.ExtractMinimum``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Extracts the minimum element from a set, returning the element along with the updated set.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.TryExtractMax``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Extracts the maximum element from a set, returning the element along with the updated set.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.TryExtractMin``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Extracts the minimum element from a set, returning the element along with the updated set.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Creates a set given a number of items in the set and a generator function.</summary>
 <param name="count"></param>
 <param name="initializer"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.MapToArray``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Applies a function to each element of the set, returning the results in an array.</summary>
 <param name="mapping"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.FoldIndexed``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpSet{``1})">
 <summary>
 Applies a function to each element of the set, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the index of the element within the set.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.IterBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Applies a function to each element of the set, in decreasing element order.</summary>
 <param name="action"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.ToVector``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds a vector that contains the elements of the set in order.</summary>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.OfVector``1(ExtCore.FSharpVector{``0})">
 <summary>Creates a set with the same elements as the vector.</summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.OfArrayView``1(System.ArraySegment{``0})">
 <summary>Creates a set with the same elements as the ArrayView.</summary>
 <param name="view"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Cartesian.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``1})">
 <summary>
 Applies the given function to each element in the Cartesian product of two sets. 
 Returns the set comprised of the results <c>x</c> for each element where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser"></param>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Cartesian.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``1})">
 <summary>
 Builds a new collection whose elements are the results of applying the given function
 to the elements in the Cartesian product of two sets.
 </summary>
 <param name="mapping"></param>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Cartesian.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``1})">
 <summary>Applies the given function to each element in the Cartesian product of two sets.</summary>
 <param name="action"></param>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Cartesian.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``1},``2)">
 <summary>
 Applies a function to each element in the Cartesian product of two sets,
 threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="set1"></param>
 <param name="set2"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.SetModule.Cartesian.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,Microsoft.FSharp.Collections.FSharpSet{``1},Microsoft.FSharp.Collections.FSharpSet{``2})">
 <summary>
 Applies a function to each element in the Cartesian product of two sets,
 threading an accumulator argument through the computation.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="set1"></param>
 <param name="set2"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.SetModule.Cartesian">
 <summary>
 Functions operating over the Cartesian product of two sets.
 These functions can offer a large memory savings since they avoid creating the product set.
 </summary>
</member>
<member name="T:ExtCore.Collections.SetModule">
<summary>
 Additional functional operators on sets.
</summary>
</member>
<member name="M:ExtCore.Collections.MapModule.FindKeys``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Applies the specified predicate function to each binding in a Map,
 returning a new Set containing the keys for which the predicate matched.
 </summary>
 <param name="predicate"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.CountWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the number of map elements matching a given predicate.</summary>
 <param name="predicate"></param>
 <param name="map"></param>
 <returns></returns>
 <remarks><c>Map.countWith predicate map = (Map.filter predicate map |> Map.count)</c></remarks>
</member>
<member name="M:ExtCore.Collections.MapModule.Update``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Like Map.add, but only overwrites the value of an existing entry.
 If the map does not contain the given key, <see cref="KeyNotFoundException"/> is raised.
 </summary>
 <param name="key"></param>
 <param name="value"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.TryUpdate``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Like Map.add, but only overwrites the value of an existing entry (i.e., it won't create a new entry in the map).
 </summary>
 <param name="key"></param>
 <param name="value"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.TryAdd``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Like Map.add, but doesn't overwrite an existing entry.</summary>
 <param name="key"></param>
 <param name="value"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.PivotWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Combines Map.ofKeys and Map.pivot to avoid creating intermediate data structures.</summary>
 <param name="mapping"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Pivot``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Creates a new Map by inverting the given Map. The keys are the values of the original Map; the corresponding value is a
 non-empty set containing the original keys which pointed to the value.
 </summary>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Inverse``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Creates a new Map by inverting the given Map. The keys are the values of the original Map; the value associated with each key
 (original value) is the greatest-valued original key associated with the original value.
 </summary>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Join``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Combines two maps into a single map. Whenever a key exists in both maps, the specified function is used to determine the
 value to be used for that key in the combined map.
 </summary>
 <param name="joiner"></param>
 <param name="map1"></param>
 <param name="map2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Union``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Combines two maps into a single map. Whenever a key exists in both maps, the first map's entry will be added to the result map.
 </summary>
 <param name="map1"></param>
 <param name="map2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.MapPartition``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``2,``3}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Like <c>Map.partition</c>, a function is applied to each binding in a map to partition it into two parts.
 <c>mapPartition</c> differs in that it allows the values in the returned maps to be different than the values in the input map,
 and it also allows the values in the returned maps to have different types.
 </summary>
 <param name="partitioner"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.IterBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Applies a function to each binding in the map, in decreasing key order.</summary>
 <param name="action"></param>
 <param name="map"></param>
</member>
<member name="M:ExtCore.Collections.MapModule.FilterKeys``2(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a new map containing only the bindings whose keys belong to a given set of keys.</summary>
 <param name="keys"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.RemoveKeys``2(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a new map containing only the bindings whose keys do not belong to a given set of keys.</summary>
 <param name="keys"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.FromValues``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Creates a new map from a set of values by applying a mapping function to each value to extract a key from it.
 If the key-mapping function returns the same key for two or more values, the returned map will only contain a
 binding for the greatest of those values.
 </summary>
 <param name="mapping"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.FromKeys``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>
 Creates a new map from a set of keys by applying a mapping function to each key to generate it's corresponding value.
 </summary>
 <param name="mapping"></param>
 <param name="set"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.FromKvpSequence``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
 <summary>Returns a new map created from a sequence of key-value pairs.</summary>
 <param name="sequence"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.AddKvp``2(System.Collections.Generic.KeyValuePair{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Adds the given KeyValuePair to the map.</summary>
 <param name="kvp"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Values``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the value set of the Map.</summary>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Keys``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the key set of the Map.</summary>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.ToVector``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a vector that contains the elements of the map in order.</summary>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.OfVector``2(ExtCore.FSharpVector{System.Tuple{``0,``1}})">
 <summary>Creates a map with the same elements as the vector.</summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Singleton``2(``0,``1)">
 <summary>The Map containing the given binding.</summary>
 <param name="key"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.FindOrDefault``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``1,``0})">
 <summary>
 Lookup a key in the map, and if found, return it's corresponding value.
 Otherwise, returns the given default value.
 </summary>
 <param name="defaultValue"></param>
 <param name="key"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.MapModule.Count``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Determines the number of items in the map.</summary>
 <param name="count"></param>
 <param name="map"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.MapModule">
<summary>
 Additional functional operators on maps.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Readonly``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Returns a read-only view of a dictionary.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Splits the Dictionary into two Dictionaries, containing the entries
 for which the given predicate evaluates to &quot;true&quot; and &quot;false&quot;.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.IDictionary{``1,``2})">
<summary>
 Applies a function to each entry of the Dictionary,
 threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Applies the given function to each element of the Dictionary.
 Returns a Dictionary comprised of the results &quot;x,y&quot; for each
 entry where the function returns Some(y).
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Builds a new Dictionary whose entries are the results of applying
 the given function to each element of the Dictionary.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Returns a new Dictionary containing only the entries of the
 Dictionary for which the predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Applies the given function to each entry in the Dictionary.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.ToSeq``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Views the Dictionary as a sequence of tuples.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Applies the given function to sucecssive entries, returning the
 first x where the function returns &quot;Some(x)&quot;.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Applies the given function to successive entries, returning the
 first result where the function returns &quot;Some(x)&quot;.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.UpdateOrAdd``2(``0,``1,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Updates the value of an entry (which has the specified key) in
 the Dictionary, or creates a new entry if one doesn&apos;t exist.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Update``2(``0,``1,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Updates the value of an entry (which has the specified key) in the Dictionary.
 Raises a KeyNotFoundException if the Dictionary does not contain an entry with the specified key.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.TryFind``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Attempts to retrieve the value associated with the specified key.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Find``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Lookup an element in the Dictionary, raising KeyNotFoundException if
 the dictionary does not contain an element with the specified key.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Remove``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Removes the entry with the specified key from the Dictionary.
 An exception is raised if the entry cannot be removed.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Add``2(``0,``1,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Adds a new entry to the dictionary.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.ContainsKey``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Determines whether the Dictionary contains an element with the specified key.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.CreateMutable``2(System.Int32)">
<summary>
 Creates a mutable dictionary with the specified capacity.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Count``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Gets the number of entries in the Dictionary.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.IsEmpty``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Determines whether the Dictionary is empty.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Values``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Views the values of the Dictionary as a sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Keys``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Views the keys of the Dictionary as a sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.Immutable``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Creates an immutable copy of a Dictionary.
 The entries are shallow-copied to the created Dictionary; that is,
 reference-typed keys and values will reference the same instances as
 in the mutable Dictionary, so care should be taken when using mutable keys and values.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.UpdateOrAdd``2(``0,``1,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Updates the value of an entry (which has the specified key)
 in the Dictionary, or creates a new entry if one doesn&apos;t exist.
 If the Dictionary is read-only, an InvalidOperationException is raised.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.Remove``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Removes the entry with the specified key from the Dictionary,
 returning a value indicating the success of the operation.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.Update``2(``0,``1,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Updates an existing entry in the dictionary with a new value,
 raising KeyNotFoundException if the Dictionary does not
 contain an element with the specified key.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.Add``2(``0,``1,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Adds a new entry to the Dictionary.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.Find``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Lookup an element in the Dictionary, raising KeyNotFoundException if
 the Dictionary does not contain an element with the specified key.
</summary>
</member>
<member name="M:ExtCore.Collections.DictModule.Safe.TryFind``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Attempts to retrieve the value associated with the specified key.
</summary>
</member>
<member name="T:ExtCore.Collections.DictModule.Safe">
<summary>
 Thread-safe functional programming operators for mutable instances of System.Collections.Generic.IDictionary.
</summary>
</member>
<member name="T:ExtCore.Collections.DictModule">
<summary>
 Functional programming operators related to the System.Collections.Generic.IDictionary type.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Builds two new maps, one containing the bindings for which the given predicate
 returns &apos;true&apos;, and the other the remaining bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Builds a new map containing only the bindings for which
 the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},ExtCore.Collections.FSharpBimap{``0,``1},``2)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,ExtCore.Collections.FSharpBimap{``1,``2})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.ToMap``2(ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Returns a Map containing the same key-value pairs as the given Bimap.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.ToArray``2(ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.ToList``2(ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.ToSeq``2(ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.OfMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.OfArray``2(System.Tuple{``0,``1}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.TryAdd``2(``0,``1,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Returns a new map with the binding added to the given map, but only when
 neither the key nor the value are already bound. If the key and/or value
 are already bound, the map is returned unchanged.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Add``2(``0,``1,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Returns a new map with the binding added to the given map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.RemoveValue``2(``0,ExtCore.Collections.FSharpBimap{``1,``0})">
<summary>
 Removes a value from the range of the map.
 No exception is raised if the value is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Remove``2(``0,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.FindValue``2(``0,ExtCore.Collections.FSharpBimap{``1,``0})">
<summary>
 Lookup a value in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Find``2(``0,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Lookup an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.TryFindValue``2(``0,ExtCore.Collections.FSharpBimap{``1,``0})">
<summary>
 Lookup a value in the map, returning a Some value if the
 element is in the range of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.TryFind``2(``0,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Lookup an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Paired``2(``0,``1,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Tests if an element and a value are bound to each other in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.ContainsValue``2(``0,ExtCore.Collections.FSharpBimap{``1,``0})">
<summary>
 Tests if a value is in the range of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.ContainsKey``2(``0,ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Count``2(ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.IsEmpty``2(ExtCore.Collections.FSharpBimap{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Singleton``2(``0,``1)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.BimapModule.Empty``2">
<summary>
 The empty Bimap.
</summary>
</member>
<member name="T:ExtCore.Collections.BimapModule">
<summary>
 Functional programming operators related to the Bimap&lt;_,_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Raise KeyNotFoundException if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Returns None if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then a KeyNotFoundException is raised.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then None is returned.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
<summary>
 Tests if all elements of the collection satisfy the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
<summary>
 Tests if any element of the collection satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Splits the set into two sets containing the elements for which the given
 predicate returns &quot;true&quot; and &quot;false&quot;, respectively.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new collection containing the results of applying the given function
 to each element of the input set.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Returns a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Applies the given function to each element of the set.
 Returns the set comprised of the results <c>x</c> for each element where the
 function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.Collections.FSharpIntSet,``0)">
<summary>
 Applies the given accumulating function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},``0,ExtCore.Collections.FSharpIntSet)">
<summary>
 Applies the given accumulating function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit},ExtCore.Collections.FSharpIntSet)">
<summary>
 Applies the given function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit},ExtCore.Collections.FSharpIntSet)">
<summary>
 Applies the given function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.ToSet``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Builds a Set that contains the same elements as the given TagSet.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.ToArray``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Builds an array that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.ToList``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Builds a list that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.ToSeq``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns an ordered view of the collection as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.OfSet``1(Microsoft.FSharp.Collections.FSharpSet{System.Int32})">
<summary>
 Builds an set that contains the same elements as the given Set.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.OfArray``1(System.Int32[])">
<summary>
 Builds a set that contains the same elements as the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 Builds a set that contains the same elements as the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.OfSeq``1(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 Builds a new collection from the given enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IsProperSuperset``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first,
 and at least one element of the first is not in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IsSuperset``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IsProperSubset``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second,
 and at least one element of the second is not in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IsSubset``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Difference``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{ExtCore.Collections.FSharpIntSet})">
<summary>
 Computes the intersection of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Intersect``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Computes the intersection of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.UnionMany``1(System.Collections.Generic.IEnumerable{ExtCore.Collections.FSharpIntSet})">
<summary>
 Computes the union of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Union``1(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Computes the union of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.MaxElementSigned``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the highest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.MaxElement``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the highest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.MinElementSigned``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the lowest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.MinElement``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the lowest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Contains``1(System.Int32,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if the given element is in the given set.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Remove``1(System.Int32,ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new set with the given element removed.
 No exception is raised if the set does not contain the element.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Add``1(System.Int32,ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new set with an element added to the set.
 No exception is raised if the set already contains the element.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Singleton``1(System.Int32)">
<summary>
 The set containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Count``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the number of elements in the set
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.IsEmpty``1(ExtCore.Collections.FSharpIntSet)">
<summary>
 Is the set empty?
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.Empty``1">
<summary>
 The empty set
</summary>
</member>
<member name="M:ExtCore.Collections.TagSetModule.RetypeInlined``2(``0)">
<summary>
 Retypes a value without emitting any IL instructions.
 WARNING: This should be used with EXTREME CAUTION.
</summary>
</member>
<member name="T:ExtCore.Collections.TagSetModule">
<summary>
 Functional programming operators related to the TagMap&lt;_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Find(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Raise KeyNotFoundException if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.TryFind(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Returns None if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Pick``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then a KeyNotFoundException is raised.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.TryPick``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then None is returned.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Forall(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
<summary>
 Tests if all elements of the collection satisfy the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Exists(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
<summary>
 Tests if any element of the collection satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Partition(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Splits the set into two sets containing the elements for which the given
 predicate returns &quot;true&quot; and &quot;false&quot;, respectively.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Map(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new collection containing the results of applying the given function
 to each element of the input set.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Filter(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Boolean},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Returns a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Choose(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},ExtCore.Collections.FSharpIntSet)">
 <summary>
 Applies the given function to each element of the set.
 Returns the set comprised of the results <c>x</c> for each element where the
 function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.Collections.FSharpIntSet,``0)">
<summary>
 Applies the given accumulating function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},``0,ExtCore.Collections.FSharpIntSet)">
<summary>
 Applies the given accumulating function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IterateBack(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit},ExtCore.Collections.FSharpIntSet)">
<summary>
 Applies the given function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Iterate(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit},ExtCore.Collections.FSharpIntSet)">
<summary>
 Applies the given function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.ToSet(ExtCore.Collections.FSharpIntSet)">
<summary>
 Builds a Set that contains the same elements as the given IntSet.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.ToArray(ExtCore.Collections.FSharpIntSet)">
<summary>
 Builds an array that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.ToList(ExtCore.Collections.FSharpIntSet)">
<summary>
 Builds a list that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.ToSeq(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns an ordered view of the collection as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.OfSet(Microsoft.FSharp.Collections.FSharpSet{System.Int32})">
<summary>
 Builds an IntSet that contains the same elements as the given Set.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.OfArray(System.Int32[])">
<summary>
 Builds a set that contains the same elements as the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.OfList(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 Builds a set that contains the same elements as the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.OfSeq(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 Builds a new collection from the given enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IsProperSuperset(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first,
 and at least one element of the first is not in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IsSuperset(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IsProperSubset(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second,
 and at least one element of the second is not in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IsSubset(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Difference(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IntersectMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.FSharpIntSet})">
<summary>
 Computes the intersection of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Intersect(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Computes the intersection of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.UnionMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.FSharpIntSet})">
<summary>
 Computes the union of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Union(ExtCore.Collections.FSharpIntSet,ExtCore.Collections.FSharpIntSet)">
<summary>
 Computes the union of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.MaxElementSigned(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the highest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.MaxElement(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the highest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.MinElementSigned(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the lowest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.MinElement(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the lowest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Contains(System.Int32,ExtCore.Collections.FSharpIntSet)">
 <summary>
 Evaluates to &quot;true&quot; if the given element is in the given set.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Remove(System.Int32,ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new set with the given element removed.
 No exception is raised if the set does not contain the element.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Add(System.Int32,ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns a new set with an element added to the set.
 No exception is raised if the set already contains the element.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Singleton(System.Int32)">
<summary>
 The set containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.Count(ExtCore.Collections.FSharpIntSet)">
<summary>
 Returns the number of elements in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.IntSetModule.IsEmpty(ExtCore.Collections.FSharpIntSet)">
<summary>
 Is the set empty?
</summary>
</member>
<member name="P:ExtCore.Collections.IntSetModule.Empty">
<summary>
 The empty set.
</summary>
</member>
<member name="T:ExtCore.Collections.IntSetModule">
<summary>
 Functional programming operators related to the IntSet type.
</summary>
</member>
<member name="M:ExtCore.Collections.BitOps32.invertSign(System.Int32)">
<summary>
 Inverts the sign bit of an 32-bit signed integer value.
</summary>
</member>
<member name="M:ExtCore.Collections.BitOps32.zeroBit(System.UInt32,System.UInt32)">
 <summary>Determines if all specified bits are cleared (not set) in a value.</summary>
 <param name="value">The value to test.</param>
 <param name="bitValue">The bits to test in 'value'.</param>
 <returns>true if all bits which are set in 'bitValue' are *not* set in 'value'.</returns>
</member>
<member name="M:ExtCore.Collections.BitOps32.mask(System.UInt32,System.UInt32)">
<summary>
 Clears the indicated bit and sets all lower bits.
</summary>
</member>
<member name="M:ExtCore.Collections.BitOps32.branchingBit(System.UInt32,System.UInt32)">
<summary>
 Finds the first (most-significant) bit at which p0 and p1 disagree.
 Returns a power-of-two value containing this (and only this) bit.
</summary>
</member>
<member name="T:ExtCore.Collections.BitOps32">
<summary>
 Bitwise operations (32-bit) necessary for implementing big-endian Patricia tries.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.MapPartition``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},ExtCore.Collections.IntMap{``0})">
<summary>
 Splits the map into two maps by applying the given partitioning function
 to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Splits the map into two maps containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Determines if all bindings in the map match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Determines if any binding in the map matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.IntMap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.IntMap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.IntMap{``0})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Filter``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
 <summary>
 Builds a new map containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},ExtCore.Collections.IntMap{``0})">
<summary>
 Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.IntMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.IntMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.ToMap``2(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new Map created from the given IntMap.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.ToArray``2(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.ToList``2(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.ToSeq``2(ExtCore.Collections.IntMap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.OfMap``2(Microsoft.FSharp.Collections.FSharpMap{System.Int32,``0})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.OfArray``2(System.Tuple{System.Int32,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Difference``2(ExtCore.Collections.IntMap{``0},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new map created by removing the second map from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Intersect``2(ExtCore.Collections.IntMap{``0},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the intersection of two maps.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Union``2(ExtCore.Collections.IntMap{``0},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new map created by merging the two specified maps.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Remove``2(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Add``2(System.Int32,``0,ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the key of the first mapping in the collection which satisfies the given
 predicate. Returns None if no such mapping is found.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.FindOrDefault``2(``0,System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Look up an element in the map, returning the given default value
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Find``2(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.TryFind``2(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Look up an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.ContainsKey``2(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Singleton``2(System.Int32,``0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Count``2(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.IsEmpty``2(ExtCore.Collections.IntMap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.Empty``2">
<summary>
 The empty map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagMapModule.RetypeInlined``2(``0)">
<summary>
 Retypes a value without emitting any IL instructions.
 WARNING: This should be used with EXTREME CAUTION.
</summary>
</member>
<member name="T:ExtCore.Collections.TagMapModule">
<summary>
 Functional programming operators related to the TagMap&lt;_,_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},ExtCore.Collections.IntMap{``0})">
<summary>
 Splits the map into two maps by applying the given partitioning function
 to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Splits the map into two maps containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Determines if all bindings in the map match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Determines if any binding in the map matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.IntMap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.IntMap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.IntMap{``0})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
 <summary>
 Builds a new map containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},ExtCore.Collections.IntMap{``0})">
<summary>
 Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.IntMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.IntMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.ToMap``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new Map created from the given IntMap.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.ToArray``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.ToList``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.ToSeq``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.OfMap``1(Microsoft.FSharp.Collections.FSharpMap{System.Int32,``0})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.OfArray``1(System.Tuple{System.Int32,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.OfSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Difference``1(ExtCore.Collections.IntMap{``0},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new map created by removing the second map from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Intersect``1(ExtCore.Collections.IntMap{``0},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the intersection of two maps.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Union``1(ExtCore.Collections.IntMap{``0},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new map created by merging the two specified maps.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Remove``1(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Add``1(System.Int32,``0,ExtCore.Collections.IntMap{``0})">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.TryFindKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the key of the first mapping in the collection which satisfies the given
 predicate. Returns None if no such mapping is found.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.MaxKeySigned``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the highest key in the map according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.MaxKey``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the highest key in the map according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.MinKeySigned``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the lowest key in the map according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.MinKey``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the lowest key in the map according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.FindOrDefault``1(``0,System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Look up an element in the map, returning the given default value
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Find``1(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.TryFind``1(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Look up an element in the map returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.ContainsKey``1(System.Int32,ExtCore.Collections.IntMap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Singleton``1(System.Int32,``0)">
<summary>
 The IntMap containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Count``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.IsEmpty``1(ExtCore.Collections.IntMap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.IntMapModule.Empty``1">
<summary>
 The empty map.
</summary>
</member>
<member name="T:ExtCore.Collections.IntMapModule">
<summary>
 Functional programming operators related to the IntMap&lt;_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.ToTagMap``2(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a TagMap with the same key-value pairs as the TagBimap.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.ToArray``2(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.ToList``2(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.ToSeq``2(ExtCore.Collections.IntBimap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.OfArray``2(System.Tuple{System.Int32,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Builds two new maps, one containing the bindings for which the given predicate
 returns &apos;true&apos;, and the other the remaining bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Builds a new map containing only the bindings for which
 the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.IntBimap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.IntBimap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns true if the given predicate returns true for every binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns true if the given predicate returns true for one or more bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.TryAdd``2(System.Int32,``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map, but only when
 neither the key nor the value are already bound. If the key and/or value
 are already bound, the map is returned unchanged.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Add``2(System.Int32,``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.RemoveValue``2(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Removes a value from the range of the map.
 No exception is raised if the value is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Remove``2(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.FindValue``2(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup a value in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Find``2(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.TryFindValue``2(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup a value in the map, returning a Some value if the
 element is in the range of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.TryFind``2(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Paired``2(System.Int32,``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Tests if an element and a value are bound to each other in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.ContainsValue``2(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Tests if a value is in the range of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.ContainsKey``2(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Count``2(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.IsEmpty``2(ExtCore.Collections.IntBimap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Singleton``3(System.Int32,``0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.Empty``2">
<summary>
 The empty TagBimap.
</summary>
</member>
<member name="M:ExtCore.Collections.TagBimapModule.RetypeInlined``2(``0)">
<summary>
 Retypes a value without emitting any IL instructions.
 WARNING: This should be used with EXTREME CAUTION.
</summary>
</member>
<member name="T:ExtCore.Collections.TagBimapModule">
<summary>
 Functional programming operators related to the TagBimap&lt;_,_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.ToIntMap``1(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns an IntMap with the same key-value pairs as the IntBimap.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.ToArray``1(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.ToList``1(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.ToSeq``1(ExtCore.Collections.IntBimap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.OfArray``1(System.Tuple{System.Int32,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.OfSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Builds two new maps, one containing the bindings for which the given predicate
 returns &apos;true&apos;, and the other the remaining bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Builds a new map containing only the bindings for which
 the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.IntBimap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.IntBimap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns true if the given predicate returns true for every binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns true if the given predicate returns true for one or more bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.TryAdd``1(System.Int32,``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map, but only when
 neither the key nor the value are already bound. If the key and/or value
 are already bound, the map is returned unchanged.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Add``1(System.Int32,``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.RemoveValue``1(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Removes a value from the range of the map.
 No exception is raised if the value is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Remove``1(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.FindValue``1(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup a value in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Find``1(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.TryFindValue``1(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup a value in the map, returning a Some value if the
 element is in the range of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.TryFind``1(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Lookup an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Paired``1(System.Int32,``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Tests if an element and a value are bound to each other in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.ContainsValue``1(``0,ExtCore.Collections.IntBimap{``0})">
<summary>
 Tests if a value is in the range of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.ContainsKey``1(System.Int32,ExtCore.Collections.IntBimap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Count``1(ExtCore.Collections.IntBimap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.IsEmpty``1(ExtCore.Collections.IntBimap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Singleton``1(System.Int32,``0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.IntBimapModule.Empty``1">
<summary>
 The empty IntBimap.
</summary>
</member>
<member name="T:ExtCore.Collections.IntBimapModule">
<summary>
 Functional programming operators related to the IntBimap type.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Raise KeyNotFoundException if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Returns None if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.LongSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then a KeyNotFoundException is raised.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.LongSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then None is returned.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
<summary>
 Tests if all elements of the collection satisfy the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
<summary>
 Tests if any element of the collection satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Splits the set into two sets containing the elements for which the given
 predicate returns &quot;true&quot; and &quot;false&quot;, respectively.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},ExtCore.Collections.LongSet)">
<summary>
 Returns a new collection containing the results of applying the given function
 to each element of the input set.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Returns a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},ExtCore.Collections.LongSet)">
 <summary>
 Applies the given function to each element of the set.
 Returns the set comprised of the results <c>x</c> for each element where the
 function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.Collections.LongSet,``0)">
<summary>
 Applies the given accumulating function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,``0}},``0,ExtCore.Collections.LongSet)">
<summary>
 Applies the given accumulating function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LongSet)">
<summary>
 Applies the given function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LongSet)">
<summary>
 Applies the given function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.ToSet``1(ExtCore.Collections.LongSet)">
<summary>
 Builds a Set that contains the same elements as the given LongTagSet.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.ToArray``1(ExtCore.Collections.LongSet)">
<summary>
 Builds an array that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.ToList``1(ExtCore.Collections.LongSet)">
<summary>
 Builds a list that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.ToSeq``1(ExtCore.Collections.LongSet)">
<summary>
 Returns an ordered view of the collection as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.OfSet``1(Microsoft.FSharp.Collections.FSharpSet{System.Int64})">
<summary>
 Builds an set that contains the same elements as the given Set.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.OfArray``1(System.Int64[])">
<summary>
 Builds a set that contains the same elements as the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 Builds a set that contains the same elements as the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.OfSeq``1(System.Collections.Generic.IEnumerable{System.Int64})">
<summary>
 Builds a new collection from the given enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IsProperSuperset``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first,
 and at least one element of the first is not in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IsSuperset``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IsProperSubset``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second,
 and at least one element of the second is not in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IsSubset``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Difference``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Returns a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{ExtCore.Collections.LongSet})">
<summary>
 Computes the intersection of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Intersect``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Computes the intersection of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.UnionMany``1(System.Collections.Generic.IEnumerable{ExtCore.Collections.LongSet})">
<summary>
 Computes the union of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Union``1(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Computes the union of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.MaxElementSigned``1(ExtCore.Collections.LongSet)">
<summary>
 Returns the highest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.MaxElement``1(ExtCore.Collections.LongSet)">
<summary>
 Returns the highest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.MinElementSigned``1(ExtCore.Collections.LongSet)">
<summary>
 Returns the lowest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.MinElement``1(ExtCore.Collections.LongSet)">
<summary>
 Returns the lowest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Contains``1(System.Int64,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if the given element is in the given set.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Remove``1(System.Int64,ExtCore.Collections.LongSet)">
<summary>
 Returns a new set with the given element removed.
 No exception is raised if the set does not contain the element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Add``1(System.Int64,ExtCore.Collections.LongSet)">
<summary>
 Returns a new set with an element added to the set.
 No exception is raised if the set already contains the element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Singleton``1(System.Int64)">
<summary>
 The set containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Count``1(ExtCore.Collections.LongSet)">
<summary>
 Returns the number of elements in the set
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.IsEmpty``1(ExtCore.Collections.LongSet)">
<summary>
 Is the set empty?
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.Empty``1">
<summary>
 The empty set
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagSetModule.RetypeInlined``2(``0)">
<summary>
 Retypes a value without emitting any IL instructions.
 WARNING: This should be used with EXTREME CAUTION.
</summary>
</member>
<member name="T:ExtCore.Collections.LongTagSetModule">
<summary>
 Functional programming operators related to the TagMap&lt;_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Find(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Raise KeyNotFoundException if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.TryFind(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Returns the first (least) element for which the given predicate returns &quot;true&quot;.
 Returns None if no such element exists.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Pick``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.LongSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then a KeyNotFoundException is raised.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.TryPick``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpOption{``0}},ExtCore.Collections.LongSet)">
 <summary>
 Applies the given function to each element of the set, returning the first result
 where the function returns <c>Some(x)</c>. If the function never returns <c>Some(x)</c>
 then None is returned.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Forall(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
<summary>
 Tests if all elements of the collection satisfy the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Exists(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
<summary>
 Tests if any element of the collection satisfies the given predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Partition(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Splits the set into two sets containing the elements for which the given
 predicate returns &quot;true&quot; and &quot;false&quot;, respectively.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Map(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Int64},ExtCore.Collections.LongSet)">
<summary>
 Returns a new collection containing the results of applying the given function
 to each element of the input set.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Filter(Microsoft.FSharp.Core.FSharpFunc{System.Int64,System.Boolean},ExtCore.Collections.LongSet)">
 <summary>
 Returns a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Choose(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpOption{System.Int64}},ExtCore.Collections.LongSet)">
 <summary>
 Applies the given function to each element of the set.
 Returns the set comprised of the results <c>x</c> for each element where the
 function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},ExtCore.Collections.LongSet,``0)">
<summary>
 Applies the given accumulating function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,``0}},``0,ExtCore.Collections.LongSet)">
<summary>
 Applies the given accumulating function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IterateBack(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LongSet)">
<summary>
 Applies the given function to each element of the set,
 in reverse order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Iterate(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LongSet)">
<summary>
 Applies the given function to each element of the set,
 in order according to the comparison function.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.ToSet(ExtCore.Collections.LongSet)">
<summary>
 Builds a Set that contains the same elements as the given LongSet.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.ToArray(ExtCore.Collections.LongSet)">
<summary>
 Builds an array that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.ToList(ExtCore.Collections.LongSet)">
<summary>
 Builds a list that contains the elements of the set in order.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.ToSeq(ExtCore.Collections.LongSet)">
<summary>
 Returns an ordered view of the collection as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.OfSet(Microsoft.FSharp.Collections.FSharpSet{System.Int64})">
<summary>
 Builds an LongSet that contains the same elements as the given Set.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.OfArray(System.Int64[])">
<summary>
 Builds a set that contains the same elements as the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.OfList(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 Builds a set that contains the same elements as the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.OfSeq(System.Collections.Generic.IEnumerable{System.Int64})">
<summary>
 Builds a new collection from the given enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IsProperSuperset(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first,
 and at least one element of the first is not in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IsSuperset(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IsProperSubset(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second,
 and at least one element of the second is not in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IsSubset(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Difference(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Returns a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IntersectMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.LongSet})">
<summary>
 Computes the intersection of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Intersect(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Computes the intersection of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.UnionMany(System.Collections.Generic.IEnumerable{ExtCore.Collections.LongSet})">
<summary>
 Computes the union of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Union(ExtCore.Collections.LongSet,ExtCore.Collections.LongSet)">
<summary>
 Computes the union of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.MaxElementSigned(ExtCore.Collections.LongSet)">
<summary>
 Returns the highest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.MaxElement(ExtCore.Collections.LongSet)">
<summary>
 Returns the highest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.MinElementSigned(ExtCore.Collections.LongSet)">
<summary>
 Returns the lowest element in the set according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.MinElement(ExtCore.Collections.LongSet)">
<summary>
 Returns the lowest element in the set according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Contains(System.Int64,ExtCore.Collections.LongSet)">
 <summary>
 Evaluates to &quot;true&quot; if the given element is in the given set.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Remove(System.Int64,ExtCore.Collections.LongSet)">
<summary>
 Returns a new set with the given element removed.
 No exception is raised if the set does not contain the element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Add(System.Int64,ExtCore.Collections.LongSet)">
<summary>
 Returns a new set with an element added to the set.
 No exception is raised if the set already contains the element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Singleton(System.Int64)">
<summary>
 The set containing the given element.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.Count(ExtCore.Collections.LongSet)">
<summary>
 Returns the number of elements in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.LongSetModule.IsEmpty(ExtCore.Collections.LongSet)">
<summary>
 Is the set empty?
</summary>
</member>
<member name="P:ExtCore.Collections.LongSetModule.Empty">
<summary>
 The empty set.
</summary>
</member>
<member name="T:ExtCore.Collections.LongSetModule">
<summary>
 Functional programming operators related to the LongSet type.
</summary>
</member>
<member name="M:ExtCore.Collections.BitOps64.invertSign(System.Int64)">
<summary>
 Inverts the sign bit of an 64-bit signed integer value.
</summary>
</member>
<member name="M:ExtCore.Collections.BitOps64.zeroBit(System.UInt64,System.UInt64)">
 <summary>Determines if all specified bits are cleared (not set) in a value.</summary>
 <param name="value">The value to test.</param>
 <param name="bitValue">The bits to test in 'value'.</param>
 <returns>true if all bits which are set in 'bitValue' are *not* set in 'value'.</returns>
</member>
<member name="M:ExtCore.Collections.BitOps64.mask(System.UInt64,System.UInt64)">
<summary>
 Clears the indicated bit and sets all lower bits.
</summary>
</member>
<member name="M:ExtCore.Collections.BitOps64.branchingBit(System.UInt64,System.UInt64)">
<summary>
 Finds the first (most-significant) bit at which p0 and p1 disagree.
 Returns a power-of-two value containing this (and only this) bit.
</summary>
</member>
<member name="T:ExtCore.Collections.BitOps64">
<summary>
 Bitwise operations (64-bit) necessary for implementing big-endian Patricia tries.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.MapPartition``4(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},ExtCore.Collections.LongMap{``0})">
<summary>
 Splits the map into two maps by applying the given partitioning function
 to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Splits the map into two maps containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Determines if all bindings in the map match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Determines if any binding in the map matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.LongMap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.LongMap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.LongMap{``0})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Filter``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
 <summary>
 Builds a new map containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},ExtCore.Collections.LongMap{``0})">
<summary>
 Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.LongMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.LongMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.ToMap``2(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new Map created from the given LongMap.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.ToArray``2(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.ToList``2(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.ToSeq``2(ExtCore.Collections.LongMap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.OfMap``2(Microsoft.FSharp.Collections.FSharpMap{System.Int64,``0})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.OfArray``2(System.Tuple{System.Int64,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Difference``2(ExtCore.Collections.LongMap{``0},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new map created by removing the second map from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Intersect``2(ExtCore.Collections.LongMap{``0},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the intersection of two maps.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Union``2(ExtCore.Collections.LongMap{``0},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new map created by merging the two specified maps.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Remove``2(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Add``2(System.Int64,``0,ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the key of the first mapping in the collection which satisfies the given
 predicate. Returns None if no such mapping is found.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.FindOrDefault``2(``0,System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Look up an element in the map, returning the given default value
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Find``2(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.TryFind``2(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Look up an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.ContainsKey``2(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Singleton``2(System.Int64,``0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Count``2(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.IsEmpty``2(ExtCore.Collections.LongMap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.Empty``2">
<summary>
 The empty map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagMapModule.RetypeInlined``2(``0)">
<summary>
 Retypes a value without emitting any IL instructions.
 WARNING: This should be used with EXTREME CAUTION.
</summary>
</member>
<member name="T:ExtCore.Collections.LongTagMapModule">
<summary>
 Functional programming operators related to the LongTagMap&lt;_,_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},ExtCore.Collections.LongMap{``0})">
<summary>
 Splits the map into two maps by applying the given partitioning function
 to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Splits the map into two maps containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Determines if all bindings in the map match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Determines if any binding in the map matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.LongMap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.LongMap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongMap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.LongMap{``0})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
 <summary>
 Builds a new map containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},ExtCore.Collections.LongMap{``0})">
<summary>
 Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.LongMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},ExtCore.Collections.LongMap{``0})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.ToMap``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new Map created from the given LongMap.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.ToArray``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.ToList``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.ToSeq``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.OfMap``1(Microsoft.FSharp.Collections.FSharpMap{System.Int64,``0})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.OfArray``1(System.Tuple{System.Int64,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.OfSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Difference``1(ExtCore.Collections.LongMap{``0},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new map created by removing the second map from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Intersect``1(ExtCore.Collections.LongMap{``0},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the intersection of two maps.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Union``1(ExtCore.Collections.LongMap{``0},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new map created by merging the two specified maps.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Remove``1(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Add``1(System.Int64,``0,ExtCore.Collections.LongMap{``0})">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.TryFindKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the key of the first mapping in the collection which satisfies the given
 predicate. Returns None if no such mapping is found.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.MaxKeySigned``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the highest key in the map according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.MaxKey``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the highest key in the map according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.MinKeySigned``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the lowest key in the map according to a signed integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.MinKey``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the lowest key in the map according to an unsigned integer comparison.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.FindOrDefault``1(``0,System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Look up an element in the map, returning the given default value
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Find``1(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.TryFind``1(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Look up an element in the map returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.ContainsKey``1(System.Int64,ExtCore.Collections.LongMap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Singleton``1(System.Int64,``0)">
<summary>
 The LongMap containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Count``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.IsEmpty``1(ExtCore.Collections.LongMap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.LongMapModule.Empty``1">
<summary>
 The empty map.
</summary>
</member>
<member name="T:ExtCore.Collections.LongMapModule">
<summary>
 Functional programming operators related to the LongMap&lt;_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.ToTagMap``2(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a TagMap with the same key-value pairs as the LongTagBimap.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.ToArray``2(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.ToList``2(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.ToSeq``2(ExtCore.Collections.LongBimap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.OfArray``2(System.Tuple{System.Int64,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Builds two new maps, one containing the bindings for which the given predicate
 returns &apos;true&apos;, and the other the remaining bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Builds a new map containing only the bindings for which
 the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.LongBimap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.LongBimap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns true if the given predicate returns true for every binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns true if the given predicate returns true for one or more bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.TryAdd``2(System.Int64,``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map, but only when
 neither the key nor the value are already bound. If the key and/or value
 are already bound, the map is returned unchanged.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Add``2(System.Int64,``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.RemoveValue``2(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Removes a value from the range of the map.
 No exception is raised if the value is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Remove``2(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.FindValue``2(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup a value in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Find``2(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.TryFindValue``2(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup a value in the map, returning a Some value if the
 element is in the range of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.TryFind``2(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Paired``2(System.Int64,``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Tests if an element and a value are bound to each other in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.ContainsValue``2(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Tests if a value is in the range of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.ContainsKey``2(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Count``2(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.IsEmpty``2(ExtCore.Collections.LongBimap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Singleton``3(System.Int64,``0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.Empty``2">
<summary>
 The empty LongTagBimap.
</summary>
</member>
<member name="M:ExtCore.Collections.LongTagBimapModule.RetypeInlined``2(``0)">
<summary>
 Retypes a value without emitting any IL instructions.
 WARNING: This should be used with EXTREME CAUTION.
</summary>
</member>
<member name="T:ExtCore.Collections.LongTagBimapModule">
<summary>
 Functional programming operators related to the LongTagBimap&lt;_,_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.ToLongMap``1(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns an LongMap with the same key-value pairs as the LongBimap.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.ToArray``1(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.ToList``1(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.ToSeq``1(ExtCore.Collections.LongBimap{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.OfArray``1(System.Tuple{System.Int64,``0}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.OfSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,``0}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Builds two new maps, one containing the bindings for which the given predicate
 returns &apos;true&apos;, and the other the remaining bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Builds a new map containing only the bindings for which
 the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},ExtCore.Collections.LongBimap{``0},``1)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,ExtCore.Collections.LongBimap{``1})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns true if the given predicate returns true for every binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns true if the given predicate returns true for one or more bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.TryAdd``1(System.Int64,``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map, but only when
 neither the key nor the value are already bound. If the key and/or value
 are already bound, the map is returned unchanged.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Add``1(System.Int64,``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns a new map with the binding added to the given map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.RemoveValue``1(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Removes a value from the range of the map.
 No exception is raised if the value is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Remove``1(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.FindValue``1(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup a value in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Find``1(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup an element in the map, raising KeyNotFoundException
 if no binding exists in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.TryFindValue``1(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup a value in the map, returning a Some value if the
 element is in the range of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.TryFind``1(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Lookup an element in the map, returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Paired``1(System.Int64,``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Tests if an element and a value are bound to each other in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.ContainsValue``1(``0,ExtCore.Collections.LongBimap{``0})">
<summary>
 Tests if a value is in the range of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.ContainsKey``1(System.Int64,ExtCore.Collections.LongBimap{``0})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Count``1(ExtCore.Collections.LongBimap{``0})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.IsEmpty``1(ExtCore.Collections.LongBimap{``0})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Singleton``1(System.Int64,``0)">
<summary>
 The map containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.LongBimapModule.Empty``1">
<summary>
 The empty LongBimap.
</summary>
</member>
<member name="T:ExtCore.Collections.LongBimapModule">
<summary>
 Functional programming operators related to the LongBimap type.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},ExtCore.Collections.HashSet{``0})">
<summary>
 Splits the set into two sets by applying the given partitioning function
 to each binding in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.Collections.HashSet{``0})">
<summary>
 Searches the set looking for the first element where the given function
 returns a Some value.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.Collections.HashSet{``0})">
<summary>
 Searches the set looking for the first element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.HashSet{``0})">
<summary>
 Returns the key of the first element in the collection which satisfies the given
 predicate. Returns None if no such element is found.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.HashSet{``0})">
<summary>
 Determines if all bindings in the set match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.HashSet{``0})">
<summary>
 Determines if any binding in the set matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.HashSet{``0})">
<summary>
 Splits the set into two sets containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.Collections.HashSet{``0})">
<summary>
 Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.HashSet{``0})">
 <summary>
 Builds a new set containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},ExtCore.Collections.HashSet{``0})">
 <summary>
 Applies the given function to each binding in the set.
 Returns the set comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},ExtCore.Collections.HashSet{``0},``1)">
<summary>
 Folds over the bindings in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,ExtCore.Collections.HashSet{``1})">
<summary>
 Folds over the bindings in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IterateBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.Collections.HashSet{``0})">
<summary>
 Applies the given function to each binding in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.Collections.HashSet{``0})">
<summary>
 Applies the given function to each binding in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.ToSet``1(ExtCore.Collections.HashSet{``0})">
<summary>
 Returns a new Set created from the given HashSet.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.ToArray``1(ExtCore.Collections.HashSet{``0})">
<summary>
 Returns an array of all elements in the set.
 The array will be ordered using generic comparison on the elements.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.ToList``1(ExtCore.Collections.HashSet{``0})">
<summary>
 Returns a list of all elements in the set.
 The list will be ordered using generic comparison on the elements.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.ToSeq``1(ExtCore.Collections.HashSet{``0})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.OfSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Returns a new set containing the given elements.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.OfArray``1(``0[])">
<summary>
 Returns a new set made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns a new set made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns a new set made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IsProperSuperset``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first,
 and at least one element of the first is not in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IsSuperset``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IsProperSubset``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second,
 and at least one element of the second is not in the first.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IsSubset``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
 <summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Difference``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
<summary>
 Returns a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{ExtCore.Collections.HashSet{``0}})">
<summary>
 Computes the intersection of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Intersect``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
<summary>
 Computes the intersection of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.UnionMany``1(System.Collections.Generic.IEnumerable{ExtCore.Collections.HashSet{``0}})">
<summary>
 Computes the union of a sequence of sets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Union``1(ExtCore.Collections.HashSet{``0},ExtCore.Collections.HashSet{``0})">
<summary>
 Computes the union of the two sets.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Contains``1(``0,ExtCore.Collections.HashSet{``0})">
<summary>
 Tests if an element is in the domain of the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Remove``1(``0,ExtCore.Collections.HashSet{``0})">
<summary>
 Removes an element from the domain of the set.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Add``1(``0,ExtCore.Collections.HashSet{``0})">
<summary>
 Returns a new set with the binding added to this set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Singleton``1(``0)">
<summary>
 The HashSet containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Count``1(ExtCore.Collections.HashSet{``0})">
<summary>
 Returns the number of bindings in the set.
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.IsEmpty``1(ExtCore.Collections.HashSet{``0})">
<summary>
 Is the set empty?
</summary>
</member>
<member name="M:ExtCore.Collections.HashSetModule.Empty``1">
<summary>
 The empty set.
</summary>
</member>
<member name="T:ExtCore.Collections.HashSetModule">
<summary>
 Functional programming operators related to the HashSet type.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.MapPartition``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``2,``3}}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Splits the map into two maps by applying the given partitioning function
 to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Splits the map into two maps containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Determines if all bindings in the map match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Determines if any binding in the map matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},ExtCore.Collections.HashMap{``0,``1},``2)">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,ExtCore.Collections.HashMap{``1,``2})">
<summary>
 Folds over the bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Applies the given function to each binding in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.Collections.HashMap{``0,``1})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.HashMap{``0,``1})">
 <summary>
 Builds a new map containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Searches the map looking for the first element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.ToMap``2(ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Returns a new Map created from the given HashMap.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.ToArray``2(ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Returns an array of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.ToList``2(ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.ToSeq``2(ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.OfMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.OfArray``2(System.Tuple{``0,``1}[])">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Returns a new map made from the given bindings.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Remove``2(``0,ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Removes an element from the domain of the map.
 No exception is raised if the element is not present.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Add``2(``0,``1,ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Returns a new map with the binding added to this map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Returns the key of the first mapping in the collection which satisfies the given
 predicate. Returns None if no such mapping is found.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.FindOrDefault``2(``0,``1,ExtCore.Collections.HashMap{``1,``0})">
<summary>
 Look up an element in the map, returning the given default value
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Find``2(``0,ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Look up an element in the map, raising KeyNotFoundException
 if the map does not contain a binding for the key.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.TryFind``2(``0,ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Look up an element in the map returning a Some value if the
 element is in the domain of the map and None if not.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.ContainsKey``2(``0,ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Tests if an element is in the domain of the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Singleton``2(``0,``1)">
<summary>
 The HashMap containing the given binding.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Count``2(ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Returns the number of bindings in the map.
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.IsEmpty``2(ExtCore.Collections.HashMap{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:ExtCore.Collections.HashMapModule.Empty``2">
<summary>
 The empty map.
</summary>
</member>
<member name="T:ExtCore.Collections.HashMapModule">
<summary>
 Functional programming operators related to the HashMap type.
</summary>
</member>
<member name="M:ExtCore.Collections.MultisetModule.CountDistinct``1(Microsoft.FSharp.Collections.FSharpMap{``0,System.UInt32})">
<summary>
 The number of distinct elements in the multiset.
</summary>
</member>
<member name="M:ExtCore.Collections.MultisetModule.Count``1(Microsoft.FSharp.Collections.FSharpMap{``0,System.UInt32})">
<summary>
 The total number of elements in the multiset.
</summary>
</member>
<member name="M:ExtCore.Collections.MultisetModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpMap{``0,System.UInt32})">
<summary>
 Is the multiset empty?
</summary>
</member>
<member name="M:ExtCore.Collections.MultisetModule.Empty``1">
<summary>
 The empty multiset.
</summary>
</member>
<member name="T:ExtCore.Collections.MultisetModule">
<summary>
 Functional programming operators related to the Multiset&lt;_&gt; type.
</summary>
</member>
<member name="M:ExtCore.Collections.MultimapModule.IsEmpty``2(Microsoft.FSharp.Collections.FSharpMap{``0,Microsoft.FSharp.Collections.FSharpSet{``1}})">
<summary>
 Is the multimap empty?
</summary>
</member>
<member name="M:ExtCore.Collections.MultimapModule.Empty``2">
<summary>
 The empty multimap.
</summary>
</member>
<member name="T:ExtCore.Collections.MultimapModule">
<summary>
 Functional programming operators related to the Multimap&lt;_,_&gt; type.
</summary>
</member>
<member name="T:ExtCore.Collections.LazyListPatterns">
<summary>
 Active patterns for deconstructing lazy lists.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Truncate``1(System.Int32,ExtCore.Collections.LazyList{``0})">
 <summary>Returns a LazyList that when enumerated returns at most N elements.</summary>
 <param name="count">The maximum number of items to enumerate.</param>
 <returns>The resulting <see cref="LazyList`1{T}"/>.</returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToVector``1(ExtCore.Collections.LazyList{``0})">
 <summary>Build a vector from the given <see cref="LazyList`1{T}"/>.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>This function will eagerly evaluate the entire list (and thus may not terminate).</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToArray``1(ExtCore.Collections.LazyList{``0})">
 <summary>Build an array from the given <see cref="LazyList`1{T}"/>.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>This function will eagerly evaluate the entire list (and thus may not terminate).</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToList``1(ExtCore.Collections.LazyList{``0})">
 <summary>Build a non-lazy list from the given collection.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>This function will eagerly evaluate the entire list (and thus may not terminate).</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToSeq``1(ExtCore.Collections.LazyList{``0})">
 <summary>Return a view of the collection as an enumerable object.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfVector``1(ExtCore.FSharpVector{``0})">
 <summary>Create a <see cref="LazyList`1{T}"/> containing the elements of the given vector.</summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfArray``1(``0[])">
 <summary>Create a <see cref="LazyList`1{T}"/> containing the elements of the given array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.copyFrom``1(System.Int32,``0[])">
<summary>
 Creates a LazyList from an array by copying elements from the array into the LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Create a <see cref="LazyList`1{T}"/> containing the elements of the given list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Build a <see cref="LazyList`1{T}"/> from the given sequence of elements.</summary>
 <param name="sequence"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LazyList{``0})">
 <summary>Apply the given function to each element of the collection.</summary>
 <param name="action"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Skip``1(System.Int32,ExtCore.Collections.LazyList{``0})">
 <summary>
 Return the list which on consumption will skip the first '<paramref name="count"/>' elements of the input list.
 </summary>
 <param name="count"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Take``1(System.Int32,ExtCore.Collections.LazyList{``0})">
 <summary>
 Return the list which on consumption will consist of at most '<paramref name="count"/>' elements of the input list.
 </summary>
 <param name="count"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,ExtCore.Collections.LazyList{``1})">
 <summary>
 Return a new list consisting of the results of applying the
 given accumulating function to successive elements of the list.
 </summary>
 <param name="folder"></param>
 <param name="state"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
 <summary>
 Return a new collection which on consumption will consist of only the
 elements of the collection for which the given predicate returns <c>true</c>.
 </summary>
 <param name="predicate"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Unzip``2(ExtCore.Collections.LazyList{System.Tuple{``0,``1}})">
 <summary>Splits a lazy list of pairs into a pair of lazy lists.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Zip``2(ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``1})">
 <summary>Return the list which contains on demand the pair of elements of the first and second list.</summary>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,ExtCore.Collections.LazyList{``1}},ExtCore.Collections.LazyList{``0})">
 <summary>Applies the given function to each element of the lazy list and concatenates all of the results.</summary>
 <param name="mapping"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``1})">
 <summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
 </summary>
 <param name="mapping"></param>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.Collections.LazyList{``0})">
 <summary>
 Build a new collection whose elements are the results of applying
 the given function to each of the elements of the collection.
 </summary>
 <param name="mapping"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>Return a list that contains the elements returned by the given computation.</summary>
 <param name="generator"></param>
 <param name="state"></param>
 <returns></returns>
 <remarks>
 The given computation is not executed until the first element on the list is consumed. The given argument is passed to the
 computation. Subsequent elements in the list are generated by again applying the residual state to the computation.
 </remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
 <summary>
 Return the first element for which the given function returns <c>true</c>.
 Raise <see cref="KeyNotFoundException"/> if no such element exists.
 </summary>
 <param name="predicate"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
 <summary>
 Apply the given function to successive elements of the list, returning the first result where function returns
 <c>Some(x)</c> for some x. If the function never returns <c>true</c>, <c>None</c> is returned.
 </summary>
 <param name="predicate"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Concat``1(ExtCore.Collections.LazyList{ExtCore.Collections.LazyList{``0}})">
 <summary>Return the list which contains on demand the list of elements of the list of lazy lists.</summary>
 <param name="lists"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Append``1(ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``0})">
 <summary>
 Return the list which contains on demand the elements of the first list followed by the elements of the second list.
 </summary>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Repeat``1(``0)">
 <summary>Return the list which on consumption will consist of an infinite sequence of the given item.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ForcedLength``1(ExtCore.Collections.LazyList{``0})">
 <summary>
 Returns the evaluated ("forced") length of the list -- i.e., the number
 of elements which have already been evaluated. Unlike <see cref="LazyList.length"/>,
 this does not force evaluation of any cells and always terminates.
 </summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Length``1(ExtCore.Collections.LazyList{``0})">
 <summary>Return the length of the list.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>This forces evaluation of the entire list and may not terminate.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Length``1(ExtCore.Collections.LazyList{``0})">
 <summary>Return the length of the list.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>This forces evaluation of the entire list and may not terminate.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.consCell``1(``0,ExtCore.Collections.LazyList{``0})">
<summary>
 Returns a new LazyListCell created by adding a value to the end of the given LazyList.
 This is simply a curried form of the Cons constructor.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Singleton``1(``0)">
 <summary>Creates a LazyList containing the given value.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Delayed``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{``0}})">
 <summary>
 Return a list that is -- in effect -- the list returned by the given computation.
 The given computation is not executed until the first element on the list is consumed.
 </summary>
 <param name="creator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ConsDelayed``1(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{``0}})">
 <summary>
 Return a new list which on consumption contains the given item followed by the list returned by the given computation.
 </summary>
 <param name="value"></param>
 <param name="creator"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Cons``1(``0,ExtCore.Collections.LazyList{``0})">
 <summary>Return a new list which contains the given item followed by the given list.</summary>
 <param name="value"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.IsEmpty``1(ExtCore.Collections.LazyList{``0})">
 <summary>Test if a list is empty.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>Forces the evaluation of the first element of the stream if it is not already evaluated.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Tail``1(ExtCore.Collections.LazyList{``0})">
 <summary>Return the list corresponding to the remaining items in the sequence.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>Forces the evaluation of the first cell of the list if it is not already evaluated.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Head``1(ExtCore.Collections.LazyList{``0})">
 <summary>Return the first element of the list.</summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>Forces the evaluation of the first cell of the list if it is not already evaluated.</remarks>
</member>
<member name="M:ExtCore.Collections.LazyListModule.TryGet``1(ExtCore.Collections.LazyList{``0})">
 <summary>Get the first cell of the list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Empty``1">
 <summary>The empty LazyList.</summary>
</member>
<member name="T:ExtCore.Collections.LazyListModule">
<summary>
 Functional operators on LazyLists.
</summary>
</member>
<member name="M:ExtCore.Collections.QueueModule.ToArray``1(ExtCore.Collections.Queue{``0})">
 <summary>Create an array containing the elements of the Queue in order.</summary>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.ToList``1(ExtCore.Collections.Queue{``0})">
 <summary>Create a list containing the elements of the Queue in order.</summary>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.ToSeq``1(ExtCore.Collections.Queue{``0})">
 <summary>Create a sequence containing the elements of the Queue in order.</summary>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.OfArray``1(``0[])">
 <summary>Creates a Queue from the elements of an array.</summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Creates a Queue from the elements of a list.</summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.Dequeue``1(ExtCore.Collections.Queue{``0})">
 <summary>Removes and returns the object at the beginning of the Queue.</summary>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.EnqueueFront``1(``0,ExtCore.Collections.Queue{``0})">
 <summary>Returns a new Queue with the object added to the front of the given Queue.</summary>
 <param name="value"></param>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.Enqueue``1(``0,ExtCore.Collections.Queue{``0})">
 <summary>Returns a new Queue with the object added to the end of the given Queue.</summary>
 <param name="value"></param>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.Length``1(ExtCore.Collections.Queue{``0})">
 <summary>The number of elements in the queue.</summary>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.IsEmpty``1(ExtCore.Collections.Queue{``0})">
 <summary>Returns true if the given queue is empty; otherwise, false.</summary>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Collections.QueueModule.Empty``1">
 <summary>Returns an empty queue of the given type.</summary>
</member>
<member name="T:ExtCore.Collections.QueueModule">
<summary>
 Functional operators related to the Queue type.
</summary>
</member>
<member name="M:ExtCore.Collections.Seq.FromAsyncSeq``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
 <summary>
 Converts asynchronous sequence to a synchronous blocking sequence.
 The elements of the asynchronous sequence are consumed lazily.
 </summary>
 <param name="input"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Collections.AsyncSeqModule.BufferMessage`1">
<summary>
 A helper type for implementation of buffering when converting 
 observable to an asynchronous sequence
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.ToObservable``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Converts asynchronous sequence to an IObservable&lt;_&gt;. When the client subscribes
 to the observable, a new copy of asynchronous sequence is started and is 
 sequentially iterated over (at the maximal possible speed). Disposing of the 
 observer cancels the iteration over asynchronous sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.FromObservable``1(System.IObservable{``0})">
<summary>
 Converts observable to an asynchronous sequence. Values that are produced
 by the observable while the asynchronous sequence is blocked are discarded
 (this function doesn&apos;t guarantee that asynchronou ssequence will return 
 all values produced by the observable)
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.FromObservableBuffered``1(System.IObservable{``0})">
<summary>
 Converts observable to an asynchronous sequence. Values that are produced
 by the observable while the asynchronous sequence is blocked are stored to 
 an unbounded buffer and are returned as next elements of the async sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.ofObservableUsingAgent``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{ExtCore.Collections.AsyncSeqModule.BufferMessage{ExtCore.Control.Notification{``0}}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Converts observable to an asynchronous sequence using an agent with
 a body specified as the argument. The returnd async sequence repeatedly 
 sends &apos;Get&apos; message to the agent to get the next element. The observable
 sends &apos;Put&apos; message to the agent (as new inputs are generated).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.ToSeq``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Converts asynchronous sequence to a synchronous blocking sequence.
 The elements of the asynchronous sequence are consumed lazily.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an asynchronous sequence that lazily takes element from an
 input synchronous sequence and returns them one-by-one.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Cache``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Create a new asynchronous sequence that caches all elements of the 
 sequence specified as the input. When accessing the resulting sequence
 multiple times, the input will still be evaluated only once
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Skip``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Skips the first N elements of an asynchronous sequence and
 then returns the rest of the sequence unmodified.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Take``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Returns the first N elements of an asynchronous sequence
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Zip3``3(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``2}})">
<summary>
 Combines three (3) asynchronous sequences into a sequence of triples. 
 The values from sequences are retrieved in parallel.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Zip``2(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}})">
<summary>
 Combines two (2) asynchronous sequences into a sequence of pairs. 
 The values from sequences are retrieved in parallel.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Pairwise``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Returns an asynchronous sequence that returns pairs containing an element
 from the input sequence and its predecessor. Empty sequence is returned for
 singleton input sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 workflow that returns the final result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Iterates over the input sequence and calls the specified function for
 every value (to perform some side-effect asynchronously).

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous
 sequence of intermediate aggregation result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are those from the
 input sequence for which the specified function returned true.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Asynchronously iterates over the input sequence and generates &apos;x&apos; for 
 every input element for which the specified asynchronous function 
 returned &apos;Some(x)&apos; 

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are generated by 
 applying the specified function to all elements of the input sequence.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``1}}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Creates an asynchronous sequence that iterates over the given input sequence.
 For every input element, it calls the the specified function and iterates
 over all elements generated by that asynchronous sequence.
 This is the &apos;bind&apos; operation of the computation expression (exposed using
 the &apos;for&apos; keyword in asyncSeq computation).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Append``1(Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}},Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Yields all elements of the first asynchronous sequence and then 
 all elements of the second asynchronous sequence.
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.LastOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Asynchronously returns the last element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.FirstOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{``0}})">
<summary>
 Asynchronously returns the first element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Singleton``1(``0)">
<summary>
 Creates an asynchronous sequence that generates a single element and then ends
</summary>
</member>
<member name="M:ExtCore.Collections.AsyncSeqModule.Empty``1">
<summary>
 Creates an empty asynchronous sequence that immediately ends
</summary>
</member>
<member name="T:ExtCore.Collections.AsyncSeqModule">
<summary>
 Module with helper functions for working with asynchronous sequences
</summary>
</member>
<member name="P:ExtCore.Collections.AsyncSeqExtensions.asyncSeq">
<summary>
 Builds asynchronous sequences using the computation expression syntax.
</summary>
</member>
<member name="T:ExtCore.Collections.AsyncSeqExtensions">
<summary>
 Automatically-opened module which extends the built-in &apos;async&apos; computation expression builder
 with additional support for AsyncSeq and also provides &apos;asyncSeq&apos;, an instance of AsyncSeqBuilder.
</summary>
</member>
<member name="T:ExtCore.Control.AsyncStatefulChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncProtectedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncReaderChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncReaderBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncMaybeBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.StatefulChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ReaderProtectedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ProtectedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ReaderChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.MaybeBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.WriterBuilder`1">
 <summary>
 </summary>
 <typeparam name="writer"></typeparam>
</member>
<member name="T:ExtCore.Control.ReaderStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ReaderBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.StateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.LazyBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.AsyncStatefulChoiceFunc`3">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.AsyncProtectedStateFunc`3">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.AsyncReaderChoiceFunc`3">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.AsyncStateFunc`2">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.AsyncReaderFunc`2">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.AsyncChoice`2">
 <summary>
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.StatefulChoiceFunc`3">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.ReaderProtectedStateFunc`4">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.ProtectedStateFunc`3">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.ReaderChoiceFunc`3">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.ReaderWriterStateFunc`4">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="Writer"></typeparam>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.IWriter`1">
 <summary>
 </summary>
 <typeparam name="Output"></typeparam>
</member>
<member name="T:ExtCore.Control.ReaderStateFunc`3">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.ReaderFunc`2">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.StateFunc`2">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.Notification`1">
 <summary>
 Union type that represents different messages that can be sent to the <see cref="T:System.IObserver`1{T}"/> interface.
 The IObserver type is equivalent to a type that only exposes an <c>OnNext</c> method accepting an instance of
 <see cref="T:Notification`1{T}"/> as an argument.
 </summary>
 <typeparam name="T">The notification argument type.</typeparam>
 <remarks>
 This type essentially replicates the functionality of the <see cref="T:System.Reactive.Notfication`1{T}"/> type
 found in the Reactive Extensions (Rx.NET) library.
 </remarks>
</member>
<member name="M:ExtCore.Control.Agents.SlidingWindowAgent`1.remove_WindowProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
 <summary>
 The event is triggered when a group of messages is collected.
 The size of the group is exactly <see cref="WindowSize"/> and the values are returned in a fresh array.
 </summary>
</member>
<member name="P:ExtCore.Control.Agents.SlidingWindowAgent`1.WindowSize">
<summary>
 The maximum number of messages included in the sliding window.
</summary>
</member>
<member name="P:ExtCore.Control.Agents.SlidingWindowAgent`1.WindowProduced">
 <summary>
 The event is triggered when a group of messages is collected.
 The size of the group is exactly <see cref="WindowSize"/> and the values are returned in a fresh array.
 </summary>
</member>
<member name="M:ExtCore.Control.Agents.SlidingWindowAgent`1.add_WindowProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
 <summary>
 The event is triggered when a group of messages is collected.
 The size of the group is exactly <see cref="WindowSize"/> and the values are returned in a fresh array.
 </summary>
</member>
<member name="M:ExtCore.Control.Agents.SlidingWindowAgent`1.Enqueue(`0)">
 <summary>Sends new message to the agent.</summary>
 <param name="message"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Control.Agents.SlidingWindowAgent`1">
 <summary>
 Agent that implements "sliding window" functionality.
 It collects messages added using the <see cref="Enqueue"/> method and emits them in overlapping groups of the specified size.
 </summary>
 <remarks>
 For example, given <c>[1,2,3,4,5...]</c> and a window size of 3, the produced groups will be <c>[1,2,3], [2,3,4], [3,4,5], ...</c>.
 </remarks>
 <typeparam name="T"></typeparam>
</member>
<member name="P:ExtCore.Control.Agents.BlockingQueueAgent`1.Count">
<summary>
 Gets the number of elements currently waiting in the queue.
</summary>
</member>
<member name="P:ExtCore.Control.Agents.BlockingQueueAgent`1.Capacity">
<summary>
 The maximum number of elements which may be present in the queue.
</summary>
</member>
<member name="M:ExtCore.Control.Agents.BlockingQueueAgent`1.Get(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Synchronously gets an item from the queue. If the queue is empty, the operation will block until one or more items are added.
 </summary>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.BlockingQueueAgent`1.AsyncGet(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Asynchronously gets an item from the queue. If the queue is empty, the operation will block until one or more items are added.
 </summary>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.BlockingQueueAgent`1.AsyncAdd(`0,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Asynchronously adds an item to the queue. The operation ends when there is a place for the item.
 If the queue is full, the operation will block until one or more items are removed.
 </summary>
 <param name="value"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Control.Agents.BlockingQueueAgent`1">
 <summary>
 Agent that implements an asynchronous queue with blocking put and blocking get operation (this implements the
 producer-consumer concurrent programming pattern). The constructor takes the maximal size of the buffer.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.Agents.BlockingAgentMessage`1">
 <summary></summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:ExtCore.Control.Agents.BatchProcessingAgent`1.remove_BatchProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. The group is not empty, but may not
 be of the specified maximal size (when the timeout elapses before enough messages is collected).
</summary>
</member>
<member name="P:ExtCore.Control.Agents.BatchProcessingAgent`1.BatchProduced">
<summary>
 The event is triggered when a group of messages is collected. The group is not empty, but may not
 be of the specified maximal size (when the timeout elapses before enough messages is collected).
</summary>
</member>
<member name="M:ExtCore.Control.Agents.BatchProcessingAgent`1.add_BatchProduced(Microsoft.FSharp.Control.FSharpHandler{`0[]})">
<summary>
 The event is triggered when a group of messages is collected. The group is not empty, but may not
 be of the specified maximal size (when the timeout elapses before enough messages is collected).
</summary>
</member>
<member name="M:ExtCore.Control.Agents.BatchProcessingAgent`1.Enqueue(`0)">
 <summary>Sends new message to the agent.</summary>
 <param name="message"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Control.Agents.BatchProcessingAgent`1">
 <summary>
 Agent that can be used to implement batch processing. It creates groups of messages (added using the <see cref="Enqueue"/> method)
 and emits them through the <see cref="BatchProduced"/> event.
 A group is produced when it reaches the maximal size or after the timeout elapses.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:ExtCore.Control.Agents.ConcurrentSetAgent`1.AsyncAdd(System.Object)">
 <summary>Adds the specified element to the set and returns <c>false</c> when it was already present in the set.</summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:ExtCore.Control.Agents.ConcurrentSetAgent`1">
 <summary>
 Agent that implements a simple concurrent set.
 The agent exposes a member that adds value to the set and returns whether the value was already present.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Occurs when the execution of the agent results in an exception.</summary>
</member>
<member name="P:ExtCore.Control.Agents.AutoCancelAgent`1.Error">
 <summary>Occurs when the execution of the agent results in an exception.</summary>
</member>
<member name="P:ExtCore.Control.Agents.AutoCancelAgent`1.CurrentQueueLength">
 <summary>Returns the number of unprocessed messages in the message queue of the agent.</summary>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Occurs when the execution of the agent results in an exception.</summary>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Scans for a message by looking through messages in arrival order until <paramref name="scanner"/>
 returns a <c>Some</c> value. Other messages remain in the queue.
 </summary>
 <param name="scanner"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Waits for a message. This will consume the first message in arrival order.</summary>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Like <see cref="PostAndReply"/>, but returns <c>None</c> if no reply within the timeout period.</summary>
 <param name="buildMessage"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.Start(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
 <summary>
 Start a new disposable agent using the specified body function (the method creates a new cancellation token for the agent).
 </summary>
 <param name="body"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
 Scans for a message by looking through messages in arrival order until <paramref name="scanner"/>
 returns a <c>Some</c> value. Other messages remain in the queue.
 </summary>
 <param name="scanner"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Waits for a message. This will consume the first message in arrival order.</summary>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Like <see cref="PostAndAsyncReply"/>, but returns <c>None</c> if no reply within the timeout period.</summary>
 <param name="buildMessage"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Posts a message to an agent and await a reply on the channel, synchronously.</summary>
 <param name="buildMessage"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Posts a message to an agent and await a reply on the channel, asynchronously.</summary>
 <param name="buildMessage"></param>
 <param name="timeout"></param>
 <returns></returns>
</member>
<member name="M:ExtCore.Control.Agents.AutoCancelAgent`1.Post(`0)">
 <summary>Posts a message to the message queue of the agent, asynchronously.</summary>
 <param name="message"></param>
</member>
<member name="T:ExtCore.Control.Agents.AutoCancelAgent`1">
 <summary>
 Wrapper for the standard F# agent (<see cref="MailboxProcessor"/>) that supports stopping of the agent's body using the
 <see cref="IDisposable"/> interface (the type automatically creates a cancellation token).
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.Agents.Agent`1">
 <summary>Type alias for the F# <see cref="MailboxProcessor"/> type.</summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:ExtCore.Control.AsyncChoiceModule.MapAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}})">
 <summary>
 When the choice value is <c>Choice1Of2(x)</c>, returns <c>Choice1Of2 (f x)</c>.
 Otherwise, when the choice value is <c>Choice2Of2(x)</c>, returns <c>Choice2Of2(x)</c>. 
 </summary>
</member>
<member name="M:ExtCore.Control.AsyncChoiceModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}})">
 <summary>
 When the choice value is <c>Choice1Of2(x)</c>, returns <c>Choice1Of2 (f x)</c>.
 Otherwise, when the choice value is <c>Choice2Of2(x)</c>, returns <c>Choice2Of2(x)</c>. 
 </summary>
</member>
<member name="M:ExtCore.Control.AsyncChoiceModule.FailWith``1(System.String)">
<summary>
 Creates an AsyncChoice representing an error value.
 The error value in the Choice is the specified error message.
</summary>
</member>
<member name="M:ExtCore.Control.AsyncChoiceModule.Error``2(``0)">
<summary>
 Creates an AsyncChoice from an error value.
</summary>
</member>
<member name="T:ExtCore.Control.AsyncChoiceModule">
<summary>
 Functions for working with AsyncChoice workflows.
</summary>
</member>
<member name="M:ExtCore.Control.AsyncModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Transforms an Async value using the specified function.
</summary>
</member>
<member name="T:ExtCore.Control.AsyncModule">
<summary>
 Functions for working with F# Async workflows.
</summary>
</member>
<member name="M:ExtCore.Control.StatefulChoiceModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.FSharpChoice{``0,``3},``2}})">
<summary>
 Transforms a value in the StatefulChoice workflow by using a specified mapping function.
</summary>
</member>
<member name="T:ExtCore.Control.StatefulChoiceModule">
 <summary>
 </summary>
</member>
<member name="M:ExtCore.Control.ProtectedStateModule.DiscardState``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``1,``0},``2}},``0)">
<summary>
 Discards the state value.
 Useful when the state value is only needed during the computation;
 by discarding the state when the computation is complete, the return
 value can be adapted to the Choice workflow.
</summary>
</member>
<member name="M:ExtCore.Control.ProtectedStateModule.Failwith``2(System.String,``0)">
<summary>
 The monadic equivalent of F#&apos;s built-in &apos;failwith&apos; operator.
</summary>
</member>
<member name="M:ExtCore.Control.ProtectedStateModule.SetError``3(``0,``1)">
<summary>
 Sets an error value in the computation. The monadic equivalent of raising an exception.
</summary>
</member>
<member name="M:ExtCore.Control.ProtectedStateModule.LiftReader``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Adapts a function designed for use with the Reader monad
 so it can be used with the ProtectedState monad.
 Used for functions which only need to read from the state.
</summary>
</member>
<member name="T:ExtCore.Control.ProtectedStateModule">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ReaderChoiceModule">
 <summary>
 </summary>
</member>
<member name="M:ExtCore.Control.ReaderStateModule.LiftState``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``0}},``2,``0)">
<summary>
 Adapts a function designed for use with the State monad
 so it can be used with the ReaderState monad.
</summary>
</member>
<member name="M:ExtCore.Control.ReaderStateModule.LiftReader``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2)">
<summary>
 Adapts a function designed for use with the State monad
 so it can be used with the ReaderState monad.
</summary>
</member>
<member name="T:ExtCore.Control.ReaderStateModule">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.ReaderModule">
 <summary>
 </summary>
</member>
<member name="M:ExtCore.Control.StateModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}},``2)">
<summary>
 Applies a function to the result of a State function to transform it
 without affecting the current state value.
</summary>
</member>
<member name="M:ExtCore.Control.StateModule.Readonly``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Adapts a function designed for use with the Reader workflow
 so it can be used with the State workflow.
 Used when a function which only reads the state needs to be
 called from within the State workflow.
</summary>
</member>
<member name="M:ExtCore.Control.StateModule.BindChoice``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``0,``1},``3}},``1)">
<summary>
 Adapts a ProtectedState function for use within a State workflow.
 If the ProtectedState function returns an exception instance when executed,
 the exception will be raised rather than being passed into the State workflow.
</summary>
</member>
<member name="T:ExtCore.Control.StateModule">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.WorkflowBuilders">
 <summary>
 </summary>
</member>
<member name="M:ExtCore.Control.AsyncExtensions.Async.StartDisposable.Static(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the specified operation using a new CancellationToken and returns
 IDisposable object that cancels the computation. This method can be used
 when implementing the Subscribe method of IObservable interface.
</summary>
</member>
<member name="M:ExtCore.Control.AsyncExtensions.Async.Cache.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an asynchronous workflow that runs the asynchronous workflow
 given as an argument at most once. When the returned workflow is 
 started for the second time, it reuses the result of the 
 previous execution.
</summary>
</member>
<member name="T:ExtCore.Control.AsyncExtensions">
 <summary>
 Type extensions for the <see cref="Microsoft.FSharp.Core.Async&lt;T&gt;"/> type.
 </summary>
</member>
<member name="M:ExtCore.Control.ObservableExtensions.Async.AwaitObservable.Static``4(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3})">
<summary>
 Creates an asynchronous workflow that will be resumed when the first of the specified
 four observables produces a value. The workflow will return a Choice value that can be
 used to identify the observable that produced the value.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableExtensions.Async.AwaitObservable.Static``3(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2})">
<summary>
 Creates an asynchronous workflow that will be resumed when the first of the specified
 three observables produces a value. The workflow will return a Choice value that can be
 used to identify the observable that produced the value.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableExtensions.Async.AwaitObservable.Static``2(System.IObservable{``0},System.IObservable{``1})">
<summary>
 Creates an asynchronous workflow that will be resumed when the first of the specified
 two observables produces a value. The workflow will return a Choice value that can be
 used to identify the observable that produced the value.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableExtensions.Async.AwaitObservable.Static``1(System.IObservable{``0})">
<summary>
 Creates an asynchronous workflow that will be resumed when the specified observables produces a value.
 The workflow will return the value produced by the observable.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableExtensions.Async.GuardedAwaitObservable.Static``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Behaves like AwaitObservable, but calls the specified guarding function
 after a subscriber is registered with the observable.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableExtensions.synchronize``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},``0})">
<summary>
 Helper that can be used for writing CPS-style code that resumes
 on the same thread where the operation was started.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableModule.AsUpdates``1(System.IObservable{``0})">
<summary>
 Turns observable into an observable that only calls OnNext method of the
 observer, but gives it a discriminated union that represents different
 kinds of events (error, next, completed)
</summary>
</member>
<member name="M:ExtCore.Control.ObservableModule.Guard``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Creates an observable that calls the specified function (each time)
 after an observer is attached to the observable. This is useful to
 make sure that events triggered by the function are handled.
</summary>
</member>
<member name="M:ExtCore.Control.ObservableModule.Windowed``1(System.Int32,System.IObservable{``0})">
<summary>
 Returns an observable that yields sliding windows of 
 containing elements drawn from the input observable. 
 Each window is returned as a fresh array.
</summary>
</member>
<member name="T:ExtCore.Control.Indexed.IndexedStatefulChoiceBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Indexed.ReaderProtectedIndexedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Indexed.ProtectedIndexedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Indexed.ReaderIndexedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Indexed.IndexedStateBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Indexed.IndexedStatefulChoiceFunc`4">
 <summary>
 </summary>
 <typeparam name="S1"></typeparam>
 <typeparam name="S2"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.Indexed.ReaderProtectedIndexedStateFunc`5">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="S1"></typeparam>
 <typeparam name="S2"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.Indexed.ProtectedIndexedStateFunc`4">
 <summary>
 </summary>
 <typeparam name="S1"></typeparam>
 <typeparam name="S2"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
</member>
<member name="T:ExtCore.Control.Indexed.ReaderWriterIndexedStateFunc`5">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="Writer"></typeparam>
 <typeparam name="S1"></typeparam>
 <typeparam name="S2"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.Indexed.ReaderIndexedStateFunc`4">
 <summary>
 </summary>
 <typeparam name="Env"></typeparam>
 <typeparam name="S1"></typeparam>
 <typeparam name="S2"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.Indexed.IndexedStateFunc`3">
 <summary>
 </summary>
 <typeparam name="S1"></typeparam>
 <typeparam name="S2"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="T:ExtCore.Control.Indexed.IndexedModule">
<summary>
 Indexed-state workflows.
</summary>
</member>
<member name="T:ExtCore.Control.Cps.ProtectedStateContBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.ChoiceContBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.MaybeContBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.StateContBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.ContBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.ProtectedStateContFunc`4">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="T:ExtCore.Control.Cps.ChoiceContFunc`3">
 <summary>
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Error"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="T:ExtCore.Control.Cps.MaybeContFunc`2">
 <summary>
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="T:ExtCore.Control.Cps.StateContFunc`3">
 <summary>
 </summary>
 <typeparam name="State"></typeparam>
 <typeparam name="T"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="T:ExtCore.Control.Cps.ContFunc`2">
 <summary>
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="T:ExtCore.Control.Cps.TransactionFunc`4">
 <summary>
 </summary>
 <typeparam name="State">The type of the state value.</typeparam>
 <typeparam name="T">The type of the result value.</typeparam>
 <typeparam name="Error"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="T:ExtCore.Control.Cps.TransactionStatus`2.Commit">
<summary>
 Committed state, returned a result.
</summary>
</member>
<member name="T:ExtCore.Control.Cps.TransactionStatus`2.Rollback">
<summary>
 Reverted state, returned a result.
</summary>
</member>
<member name="T:ExtCore.Control.Cps.TransactionStatus`2.Dirty">
<summary>
 Committed state, returned an error.
</summary>
</member>
<member name="T:ExtCore.Control.Cps.TransactionStatus`2.Abort">
<summary>
 Reverted state, returned an error.
</summary>
</member>
<member name="T:ExtCore.Control.Cps.TransactionStatus`2">
 <summary>
 </summary>
 <typeparam name="T">The type of the result value.</typeparam>
 <typeparam name="Error">The type of the error value.</typeparam>
</member>
<member name="T:ExtCore.Control.Cps.ChoiceContModule">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.StateContModule">
 <summary>
 </summary>
</member>
<member name="M:ExtCore.Control.Cps.ContModule.CallCC``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1})">
<summary>
 Call with current continuation.
</summary>
</member>
<member name="T:ExtCore.Control.Cps.ContModule">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Cps.WorkflowBuilders">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Tasks.TaskBuilder">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Tasks.WorkflowBuilders">
 <summary>
 </summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.HashSetModule">
<summary>
 The HashSet module, lifted into the State monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.TagSetModule">
<summary>
 The TagSet module, lifted into the State monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.IntSetModule">
<summary>
 The IntSet module, lifted into the State monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.SetModule">
<summary>
 The F# Set module, lifted into the State monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.ReduceBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}}}},System.ArraySegment{``0},``1)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 Raises ArgumentException if the ArrayView is empty (has a Count of zero (0)).
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.Reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}}}},System.ArraySegment{``0},``1)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 Raises ArgumentException if the ArrayView is empty (has a Count of zero (0)).
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.FoldIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}}}}},``0,System.ArraySegment{``1},``2)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the ArrayView index of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}}}},``0,System.ArraySegment{``1},``2)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation; this allows
 the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation; this allows
 the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of ArrayView.iteri which threads an accumulator through the computation; this allows
 the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayViewModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of ArrayView.iter which threads an accumulator through the computation; this allows
 the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.ArrayViewModule">
<summary>
 The ExtCore.Collections.ArrayView module, lifted into the State monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.TaggedArrayModule.FoldIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}}}}},``0,``1[],``2)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
 The index values are tagged with a unit-of-measure type before applying them to the folder function.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.TaggedArrayModule.MapIndexedBack``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}}},``0[],``1)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input array from right-to-left.
 The index values are tagged with a unit-of-measure type before applying them to the mapping function.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.TaggedArrayModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}}},``0[],``1)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 The index values are tagged with a unit-of-measure type before applying them to the mapping function.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.TaggedArrayModule">
<summary>
 The ExtCore.Collections.TaggedArray module, lifted into the State monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ListModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 A specialization of List.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ListModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 A specialization of List.map which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ListModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 A specialization of List.iterBack which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ListModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 A specialization of List.iteri which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ListModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 A specialization of List.iter which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.ListModule">
<summary>
 The standard F# List module, lifted into the State monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.ReduceBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}}}},``0[],``1)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 Raises ArgumentException if the array is empty (has a length of zero (0)).
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.Reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}}}},``0[],``1)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 Raises ArgumentException if the array is empty (has a length of zero (0)).
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.FoldIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}}}}},``0,``1[],``2)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}}}},``0,``1[],``2)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.MapIndexed2``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}}},``0[],``1[],``2)">
<summary>
 A specialization of Array.mapi2 which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input arrays from left-to-right.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.Map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}},``0[],``1[],``2)">
<summary>
 A specialization of Array.map2 which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input arrays from left-to-right.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.MapIndexedBack``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}}},``0[],``1)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input array from right-to-left.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.MapBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``0[],``1)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input array from right-to-left.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}}},``0[],``1)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``0[],``1)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}},``0[],``1)">
<summary>
 A specialization of Array.iteri which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StateModule.ArrayModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},``0[],``1)">
<summary>
 A specialization of Array.iter which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StateModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the State monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderModule.HashSetModule">
<summary>
 The HashSet module, lifted into the Reader monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderModule.TagSetModule">
<summary>
 The TagSet module, lifted into the Reader monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderModule.IntSetModule">
<summary>
 The IntSet module, lifted into the Reader monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderModule.SetModule">
<summary>
 The F# Set module, lifted into the Reader monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the Reader monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.HashSetModule">
<summary>
 The HashSet module, lifted into the ReaderState monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.TagSetModule">
<summary>
 The TagSet module, lifted into the ReaderState monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.IntSetModule">
<summary>
 The IntSet module, lifted into the ReaderState monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.SetModule">
<summary>
 The F# Set module, lifted into the ReaderState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayViewModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayViewModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayViewModule.IterateIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.Unit,``2}}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of ArrayView.iteri which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayViewModule.Iterate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.Unit,``2}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of ArrayView.iter which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.ArrayViewModule">
<summary>
 The ExtCore.Collections.ArrayView module, lifted into the ReaderState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.TaggedArrayModule.FoldIndexed``5(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,``3}}}}}},``0,``1[],``2,``3)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
 The index values are tagged with a unit-of-measure type before applying them to the folder function.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.TaggedArrayModule.MapIndexedBack``5(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input array from right-to-left.
 The index values are tagged with a unit-of-measure type before applying them to the mapping function.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.TaggedArrayModule.MapIndexed``5(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 The index values are tagged with a unit-of-measure type before applying them to the mapping function.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.TaggedArrayModule">
<summary>
 The ExtCore.Collections.TaggedArray module, lifted into the ReaderState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.FoldIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,``3}}}}}},``0,``1[],``2,``3)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
 The integer index passed to the function indicates the array index of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.Fold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,``3}}}}},``0,``1[],``2,``3)">
<summary>
 Applies a function to each element of the collection, threading an accumulator argument through the computation.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.MapIndexed2``5(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``4,``3}}}}}},``0[],``1[],``2,``3)">
<summary>
 A specialization of Array.mapi2 which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input arrays from left-to-right.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.Map2``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``4,``3}}}}},``0[],``1[],``2,``3)">
<summary>
 A specialization of Array.map2 which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input arrays from left-to-right.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.MapIndexedBack``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input array from right-to-left.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.MapBack``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
 This function traverses the input array from right-to-left.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation;
 this allows the use of mapping functions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.IterateIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.Unit,``2}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.iteri which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderStateModule.ArrayModule.Iterate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.Unit,``2}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.iter which threads an accumulator through the computation;
 this allows the use of actions requiring a (possibly mutable) state variable.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderStateModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the ReaderState monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.MaybeModule.ArrayViewModule">
<summary>
 The ArrayView module, lifted into the Maybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.MaybeModule.SetModule">
<summary>
 The standard F# Set module, lifted into the Maybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.MaybeModule.SeqModule">
<summary>
 The standard F# Seq module, lifted into the Maybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.MaybeModule.ListModule">
<summary>
 The standard F# List module, lifted into the Maybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.MaybeModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the Maybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderMaybeModule.ArrayViewModule">
<summary>
 The ArrayView module, lifted into the ReaderMaybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderMaybeModule.SetModule">
<summary>
 The standard F# Set module, lifted into the ReaderMaybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderMaybeModule.SeqModule">
<summary>
 The standard F# Seq module, lifted into the ReaderMaybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderMaybeModule.ListModule">
<summary>
 The standard F# List module, lifted into the ReaderMaybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderMaybeModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the ReaderMaybe monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ChoiceModule.ArrayViewModule">
<summary>
 The ArrayView module, lifted into the Choice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ChoiceModule.SetModule">
<summary>
 The standard F# Set module, lifted into the Choice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ChoiceModule.SeqModule">
<summary>
 The standard F# Seq module, lifted into the Choice monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ChoiceModule.ListModule.ReduceBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``0,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN-1 iN))</c>.
 </summary>
 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="reduction">The function to reduce two list elements to a single element.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The final reduced value.</returns>
</member>
<member name="M:ExtCore.Control.Collections.ChoiceModule.ListModule.Reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``0,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on.
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes
 <c>f (... (f i0 i1) i2 ...) iN</c>.
 </summary>
 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="reduction">The function to reduce two list elements to a single element.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The final reduced value.</returns>
</member>
<member name="T:ExtCore.Control.Collections.ChoiceModule.ListModule">
<summary>
 The standard F# List module, lifted into the Choice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ChoiceModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the Choice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderChoiceModule.ArrayViewModule">
<summary>
 The ArrayView module, lifted into the ReaderChoice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderChoiceModule.SetModule">
<summary>
 The standard F# Set module, lifted into the ReaderChoice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderChoiceModule.SeqModule">
<summary>
 The standard F# Seq module, lifted into the ReaderChoice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderChoiceModule.ListModule">
<summary>
 The standard F# List module, lifted into the ReaderChoice monad.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderChoiceModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the ReaderChoice monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayViewModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``2,``1},``3}}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of ArrayView.mapi which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayViewModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``2,``1},``3}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of ArrayView.map which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayViewModule.IterateIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``1},``2}}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of ArrayView.iteri which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayViewModule.Iterate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``1},``2}}},System.ArraySegment{``0},``1)">
<summary>
 A specialization of ArrayView.iter which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ProtectedStateModule.ArrayViewModule">
<summary>
 The ExtCore.Collections.ArrayView module, lifted into the ProtectedState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ListModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``2,``1},``3}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 A specialization of List.map which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ProtectedStateModule.ListModule">
<summary>
 The standard F# List module, lifted into the ProtectedState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``2,``1},``3}}}},``0[],``1)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``2,``1},``3}}},``0[],``1)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayModule.IterateIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``1},``2}}}},``0[],``1)">
<summary>
 A specialization of Array.iteri which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ProtectedStateModule.ArrayModule.Iterate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``1},``2}}},``0[],``1)">
<summary>
 A specialization of Array.iter which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ProtectedStateModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the ProtectedState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayViewModule.MapIndexed``5(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``3,``2},``4}}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of ArrayView.mapi which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayViewModule.Map``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``3,``2},``4}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of ArrayView.map which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayViewModule.IterateIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``2},``3}}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of ArrayView.iteri which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayViewModule.Iterate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``2},``3}}}},System.ArraySegment{``0},``1,``2)">
<summary>
 A specialization of ArrayView.iter which threads an accumulator through the
 computation and which also short-circuits the computation if the mapping function
 returns an error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayViewModule">
<summary>
 The ExtCore.Collections.ArrayView module, lifted into the ReaderProtectedState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ListModule.Map``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``3,``2},``4}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1,``2)">
<summary>
 A specialization of List.map which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderProtectedStateModule.ListModule">
<summary>
 The standard F# List module, lifted into the ReaderProtectedState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayModule.MapIndexed``5(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``3,``2},``4}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.mapi which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayModule.Map``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{``3,``2},``4}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayModule.IterateIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``2},``3}}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.iteri which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayModule.Iterate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpChoice{System.Tuple{Microsoft.FSharp.Core.Unit,``2},``3}}}},``0[],``1,``2)">
<summary>
 A specialization of Array.iter which threads an accumulator through the computation
 and which also short-circuits the computation if the mapping function returns an
 error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.ReaderProtectedStateModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the ReaderProtectedState monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.StatefulChoiceModule.ArrayModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.FSharpChoice{``2,``3},``1}}},``0[],``1)">
<summary>
 A specialization of Array.map which threads an accumulator through the computation and which also
 short-circuits the computation if the mapping function returns an error when any element is applied to it.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.StatefulChoiceModule.ArrayModule">
<summary>
 The standard F# Array module, lifted into the StatefulChoice monad.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.SeqModule.Lift``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns a new sequence created by transforming each element of an
 sequence into an Async value which returns the element when executed.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.SeqModule.ParallelModule.Batch``1(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Segments a sequence of asynchronously-computed values into batches; the values
 within each batch are computed in parallel while the batches are computed
 sequentially. Computing the values in batches makes it possible to take advantage
 of parallelism when processing a large collection while also avoiding the need
 to wait for the entire dataset to be processed before returning.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncModule.SeqModule">
<summary>
 The standard F# Seq module, adapted for use within &apos;async&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.iteri2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.iteri2Impl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},System.Int32)">
<summary>
 Async implementation of Async.iteri2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.iteriImpl``1(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 Async implementation of Async.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.iter2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.iter2Impl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Async implementation of Async.iter2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.iterImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of Async.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Async implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.initImpl``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{``0}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32,System.Int32)">
<summary>
 Async implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.findIndex.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.tryFindIndex.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.tryFindIndexImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 Async implementation of List.tryFindIndex.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.find.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.tryFind.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.tryFindImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.tryFind.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.filter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.filterImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.filter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.forall2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.forall2Impl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Async implementation of List.forall2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.forallImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.exists2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.exists2Impl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Async implementation of List.exists2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.existsImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Collections.FSharpList{``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.collect.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.collectImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Collections.FSharpList{``1}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.collect.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Choose2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``2}}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.choose2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.choose2Impl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Async implementation of List.choose2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.choose.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.chooseImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.choose.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``2}}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)">
 <summary>Async implementation of List.foldBack2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.foldBack2Impl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,``2,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)">
<summary>
 Async implementation of List.foldBack2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 Async implementation of List.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.foldBackImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 Async implementation of List.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}}}},``0,Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Async implementation of List.fold2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.fold2Impl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,``2,Microsoft.FSharp.Control.FSharpAsync{``0}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2},``0)">
<summary>
 Async implementation of List.fold2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Async implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.foldImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{``0}},Microsoft.FSharp.Collections.FSharpList{``1},``0)">
<summary>
 Async implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.mapi2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.mapi2Impl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},System.Int32)">
<summary>
 Async implementation of List.mapi2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.mapiImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 Async implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``3}}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Async implementation of List.map3.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.map3Impl``4(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,``2,Microsoft.FSharp.Control.FSharpAsync{``3}},Microsoft.FSharp.Collections.FSharpList{``3},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
<summary>
 Async implementation of List.map3.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Async implementation of List.map2.</summary>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.map2Impl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Async implementation of List.map2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.mapImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Async implementation of List.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ListModule.Lift``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns a new list created by transforming each element of an
 list into an Async value which returns the element when executed.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncModule.ListModule">
<summary>
 The standard F# List module, adapted for use within &apos;async&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
<summary>
 Async implementation of Array.pick.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
<summary>
 Async implementation of Array.tryPick.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.tryPickImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},``0[],System.Int32)">
<summary>
 Async implementation of Array.tryPick.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[])">
<summary>
 Async implementation of Array.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.forallImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[],System.Int32)">
<summary>
 Async implementation of Array.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[])">
<summary>
 Async implementation of Array.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.existsImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[],System.Int32)">
<summary>
 Async implementation of Array.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[])">
<summary>
 Async implementation of Array.findIndex.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[])">
<summary>
 Async implementation of Array.tryFindIndex.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.tryFindIndexImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[],System.Int32)">
<summary>
 Async implementation of Array.tryFindIndex.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[])">
<summary>
 Async implementation of Array.find.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[])">
<summary>
 Async implementation of Array.tryFind.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.tryFindImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},``0[],System.Int32)">
<summary>
 Async implementation of Array.tryFind.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0[])">
<summary>
 Async implementation of Array.reduceBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0[])">
<summary>
 Async implementation of Array.reduce.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.MapPartition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0[])">
<summary>
 Async implementation of Array.mapPartition.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}}}},``0[],``1[])">
<summary>
 Async implementation of Array.mapi2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}}},``0[],``1[])">
<summary>
 Async implementation of Array.map2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}}},``0[])">
<summary>
 Async implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[])">
<summary>
 Async implementation of Array.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},``0[])">
<summary>
 Async implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.iteriImpl``1(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},``0[],System.Int32)">
<summary>
 Async implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},``0[])">
<summary>
 Async implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.iterImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},``0[],System.Int32)">
<summary>
 Async implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Async implementation of Array.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.FoldIndexedBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``1}}}},``0[],``1)">
<summary>
 Async implementation of Array.foldiBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.foldiBackImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[],``1,System.Int32)">
<summary>
 Async implementation of Array.foldiBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.FoldIndexed``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}}},``0,``1[])">
<summary>
 Async implementation of Array.foldi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.foldiImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,System.Int32,``1,Microsoft.FSharp.Control.FSharpAsync{``0}},``1[],``0,System.Int32)">
<summary>
 Async implementation of Array.foldi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``1}}},``0[],``1)">
<summary>
 Async implementation of Array.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.foldBackImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[],``1,System.Int32)">
<summary>
 Async implementation of Array.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,``1[])">
<summary>
 Async implementation of Array.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.foldImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{``0}},``1[],``0,System.Int32)">
<summary>
 Async implementation of Array.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncModule.ArrayModule.Lift``1(``0[])">
<summary>
 Returns a new array created by transforming each element of an
 array into an Async value which returns the element when executed.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncModule.ArrayModule">
<summary>
 The standard F# Array module, adapted for use within &apos;async&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.iteriImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1,System.Int32)">
<summary>
 AsyncState implementation of Async.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.iterImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of Async.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.Initialize``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``0}}}},``0)">
<summary>
 AsyncState implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.initImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``0}}},Microsoft.FSharp.Collections.FSharpList{``1},``0,System.Int32,System.Int32)">
<summary>
 AsyncState implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.FSharpOption{``2},``1}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.choose.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.chooseImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.FSharpOption{``2},``1}}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.choose.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.mapiImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},``1,System.Int32)">
<summary>
 AsyncState implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ListModule.mapImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncState implementation of List.map.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncStateModule.ListModule">
<summary>
 The standard F# List module, adapted for use within &apos;asyncState&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.MapIndexed2``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``3,``2}}}}}},``0[],``1[],``2)">
<summary>
 AsyncState implementation of Array.mapi2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.mapi2Impl``4(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,``2,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``3,``2}}},``3[],``0[],``1[],``2,System.Int32)">
<summary>
 AsyncState implementation of Array.mapi2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.Map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``3,``2}}}}},``0[],``1[],``2)">
<summary>
 AsyncState implementation of Array.map2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.map2Impl``4(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,``2,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``3,``2}}},``3[],``0[],``1[],``2,System.Int32)">
<summary>
 AsyncState implementation of Array.map2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}}}},``0[],``1)">
<summary>
 AsyncState implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.mapiImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}},``2[],``0[],``1,System.Int32)">
<summary>
 AsyncState implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}}},``0[],``1)">
<summary>
 AsyncState implementation of Array.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.mapImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``2,``1}}},``2[],``0[],``1,System.Int32)">
<summary>
 AsyncState implementation of Array.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}}},``0[],``1)">
<summary>
 AsyncState implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.iteriImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},``0[],``1,System.Int32)">
<summary>
 AsyncState implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}}},``0[],``1)">
<summary>
 AsyncState implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.iterImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{Microsoft.FSharp.Core.Unit,``1}}},``0[],``1,System.Int32)">
<summary>
 AsyncState implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.Init``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``0}}}},``0)">
<summary>
 AsyncState implementation of Array.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncStateModule.ArrayModule.initImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``0}}},``1[],``0,System.Int32)">
<summary>
 AsyncState implementation of Array.init.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncStateModule.ArrayModule">
<summary>
 The standard F# Array module, adapted for use within &apos;asyncState&apos; workflows.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncMaybeModule.SeqModule">
<summary>
 The standard F# Seq module, adapted for use within &apos;asyncMaybe&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.iteriImpl``1(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 AsyncMaybe implementation of Async.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.iterImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of Async.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 AsyncMaybe implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.initImpl``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32,System.Int32)">
<summary>
 AsyncMaybe implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.filter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.filterImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.filter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.forallImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.existsImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{``1}}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.collect.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.collectImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{``1}}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.collect.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncMaybe implementation of List.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.foldBackImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncMaybe implementation of List.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 AsyncMaybe implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.foldImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}},Microsoft.FSharp.Collections.FSharpList{``1},``0)">
<summary>
 AsyncMaybe implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.mapiImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 AsyncMaybe implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ListModule.mapImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncMaybe implementation of List.map.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncMaybeModule.ListModule">
<summary>
 The standard F# List module, adapted for use within &apos;asyncMaybe&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.forallImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},``0[],System.Int32)">
<summary>
 AsyncMaybe implementation of Array.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.existsImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Boolean}}},``0[],System.Int32)">
<summary>
 AsyncMaybe implementation of Array.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.reduceBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.reduce.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``2}}}}},``0[],``1[])">
<summary>
 AsyncMaybe implementation of Array.mapi2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``2}}}},``0[],``1[])">
<summary>
 AsyncMaybe implementation of Array.map2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.iteriImpl``1(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}},``0[],System.Int32)">
<summary>
 AsyncMaybe implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}},``0[])">
<summary>
 AsyncMaybe implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.iterImpl``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.Unit}}},``0[],System.Int32)">
<summary>
 AsyncMaybe implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 AsyncMaybe implementation of Array.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.FoldIndexedBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}}}},``0[],``1)">
<summary>
 AsyncMaybe implementation of Array.foldiBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.foldiBackImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},``0[],``1,System.Int32)">
<summary>
 AsyncMaybe implementation of Array.foldiBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.FoldIndexed``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}}}},``0,``1[])">
<summary>
 AsyncMaybe implementation of Array.foldi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.foldiImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,System.Int32,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}},``1[],``0,System.Int32)">
<summary>
 AsyncMaybe implementation of Array.foldi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}}},``0[],``1)">
<summary>
 AsyncMaybe implementation of Array.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.foldBackImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},``0[],``1,System.Int32)">
<summary>
 AsyncMaybe implementation of Array.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}}},``0,``1[])">
<summary>
 AsyncMaybe implementation of Array.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule.foldImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}},``1[],``0,System.Int32)">
<summary>
 AsyncMaybe implementation of Array.fold.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncMaybeModule.ArrayModule">
<summary>
 The standard F# Array module, adapted for use within &apos;asyncMaybe&apos; workflows.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncChoiceModule.SeqModule">
<summary>
 The standard F# Seq module, adapted for use within &apos;asyncChoice&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.iteriImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 AsyncChoice implementation of Async.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.iterImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of Async.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Initialize``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``1}}})">
<summary>
 AsyncChoice implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.initImpl``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32,System.Int32)">
<summary>
 AsyncChoice implementation of List.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.filter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.filterImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.filter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.forallImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.existsImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Collect``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Collections.FSharpList{``1},``2}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.collect.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.collectImpl``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Collections.FSharpList{``1},``2}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.collect.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncChoice implementation of List.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.foldBackImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 AsyncChoice implementation of List.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 AsyncChoice implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.foldImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}},Microsoft.FSharp.Collections.FSharpList{``1},``0)">
<summary>
 AsyncChoice implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.mapiImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 AsyncChoice implementation of List.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ListModule.mapImpl``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 AsyncChoice implementation of List.map.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncChoiceModule.ListModule">
<summary>
 The standard F# List module, adapted for use within &apos;asyncChoice&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},``0[])">
<summary>
 AsyncChoice implementation of Array.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.forallImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},``0[],System.Int32)">
<summary>
 AsyncChoice implementation of Array.forall.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},``0[])">
<summary>
 AsyncChoice implementation of Array.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.existsImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{System.Boolean,``1}}},``0[],System.Int32)">
<summary>
 AsyncChoice implementation of Array.exists.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.ReduceBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``1}}}},``0[])">
<summary>
 AsyncChoice implementation of Array.reduceBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``1}}}},``0[])">
<summary>
 AsyncChoice implementation of Array.reduce.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.MapIndexed2``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``2,``3}}}}},``0[],``1[])">
<summary>
 AsyncChoice implementation of Array.mapi2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``2,``3}}}},``0[],``1[])">
<summary>
 AsyncChoice implementation of Array.map2.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.MapIndexed``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}}},``0[])">
<summary>
 AsyncChoice implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0[])">
<summary>
 AsyncChoice implementation of Array.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.IterateIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}}},``0[])">
<summary>
 AsyncChoice implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.iteriImpl``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}},``0[],System.Int32)">
<summary>
 AsyncChoice implementation of Array.iteri.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}},``0[])">
<summary>
 AsyncChoice implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.iterImpl``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,``1}}},``0[],System.Int32)">
<summary>
 AsyncChoice implementation of Array.iter.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Init``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``1}}})">
<summary>
 AsyncChoice implementation of Array.init.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.FoldIndexedBack``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}}}},``0[],``1)">
<summary>
 AsyncChoice implementation of Array.foldiBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.foldiBackImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{System.Int32,``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0[],``1,System.Int32)">
<summary>
 AsyncChoice implementation of Array.foldiBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.FoldIndexed``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}}}},``0,``1[])">
<summary>
 AsyncChoice implementation of Array.foldi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.foldiImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,System.Int32,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}},``1[],``0,System.Int32)">
<summary>
 AsyncChoice implementation of Array.foldi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}}},``0[],``1)">
<summary>
 AsyncChoice implementation of Array.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.foldBackImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0[],``1,System.Int32)">
<summary>
 AsyncChoice implementation of Array.foldBack.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}}},``0,``1[])">
<summary>
 AsyncChoice implementation of Array.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule.foldImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}},``1[],``0,System.Int32)">
<summary>
 AsyncChoice implementation of Array.fold.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.AsyncChoiceModule.ArrayModule">
<summary>
 The standard F# Array module, adapted for use within &apos;asyncChoice&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.ContModule.ListModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``2}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Cont implementation of List.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.ContModule.ListModule.foldImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``2}},Microsoft.FSharp.Collections.FSharpList{``1},``0)">
<summary>
 Cont implementation of List.fold.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.Cps.ContModule.ListModule">
<summary>
 The standard F# List module, adapted for use within &apos;cont&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.ContModule.ArrayModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``2}}},``0,``1[])">
<summary>
 Cont implementation of Array.fold.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.ContModule.ArrayModule.foldImpl``3(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``2}},``1[],``0,System.Int32)">
<summary>
 Cont implementation of Array.fold.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.Cps.ContModule.ArrayModule">
<summary>
 The standard F# Array module, adapted for use within &apos;cont&apos; workflows.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.StateContModule.ArrayModule.MapIndexed``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``2,``1},``3},``3}}}},``0[])">
<summary>
 StateCont implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.StateContModule.ArrayModule.mapiImpl``4(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``2,``1},``3},``3}}}},``2[],``0[],System.Int32)">
<summary>
 StateCont implementation of Array.mapi.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.StateContModule.ArrayModule.Map``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``2,``1},``3},``3}}},``0[])">
<summary>
 StateCont implementation of Array.map.
</summary>
</member>
<member name="M:ExtCore.Control.Collections.Cps.StateContModule.ArrayModule.mapImpl``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``2,``1},``3},``3}}},``2[],``0[],System.Int32)">
<summary>
 StateCont implementation of Array.map.
</summary>
</member>
<member name="T:ExtCore.Control.Collections.Cps.StateContModule.ArrayModule">
<summary>
 The standard F# Array module, adapted for use within &apos;stateCont&apos; workflows.
</summary>
</member>
<member name="F:ExtCore.Caching.LruCache`2.empty">
<summary>
 The empty cache instance.
</summary>
</member>
<member name="P:ExtCore.Caching.LruCache`2.Item(`0,`1)">
 <inherit />
</member>
<member name="P:ExtCore.Caching.LruCache`2.Values">
 <inherit />
</member>
<member name="P:ExtCore.Caching.LruCache`2.MostRecentKey">
<summary>
 The newest (most-recently-used) key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Caching.LruCache`2.LeastRecentKey">
<summary>
 The oldest (least-recently-used) key stored in the map.
</summary>
</member>
<member name="P:ExtCore.Caching.LruCache`2.Keys">
 <inherit />
</member>
<member name="P:ExtCore.Caching.LruCache`2.Item(`0)">
 <inherit />
</member>
<member name="P:ExtCore.Caching.LruCache`2.IsReadOnly">
 <inherit />
</member>
<member name="P:ExtCore.Caching.LruCache`2.IsEmpty">
<summary>
 Is the cache empty?
</summary>
</member>
<member name="P:ExtCore.Caching.LruCache`2.Empty">
<summary>
 The empty cache instance.
</summary>
</member>
<member name="P:ExtCore.Caching.LruCache`2.Count">
 <inherit />
</member>
<member name="P:ExtCore.Caching.LruCache`2.Count">
<summary>
 The number of values stored in the cache.
</summary>
</member>
<member name="P:ExtCore.Caching.LruCache`2.Capacity">
<summary>
 The maximum number of values which may be stored in the cache.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-IDictionary`2-TryGetValue(`0,`1@)">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.TryFind(`0)">
<summary>
 Look up a key in the cache, returning Some with the associated value if
 if the key is in the domain of the cache and None if not. The (possibly)
 updated cache is also returned.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.TryExtract(`0)">
<summary>
 Try to extract the specified key from the cache, returning
 the key and it&apos;s associated value along with the updated cache.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-IDictionary`2-Remove(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-ICollection`1-Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}})">
<summary>
 Builds a new cache whose values are the results of applying the given function
 to each key-value pair in the cache. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.IterateBack(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 newest (most-recently-used) to oldest (least-recently-used).
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 oldest (least-recently-used) to newest (most-recently-used).
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-IEnumerable`1-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-IEnumerable-GetEnumerator">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.FoldBack``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 newest (most-recently-used) to oldest (least-recently-used), threading an
 accumulator value through the computation.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}}},``0)">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 oldest (least-recently-used) to newest (most-recently-used), threading an
 accumulator value through the computation.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.Equals(ExtCore.Caching.LruCache{`0,`1},ExtCore.Caching.LruCache{`0,`1})">
<summary>
 Compare two LruCache instances for equality.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.Create(System.UInt32)">
<summary>
 Create a new LruCache with the specified capacity.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-ICollection`1-CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-IDictionary`2-ContainsKey(`0)">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.ContainsKey(`0)">
<summary>
 Tests if a key is in the domain of the cache.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-ICollection`1-Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-ICollection`1-Clear">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-IDictionary`2-Add(`0,`1)">
 <inherit />
</member>
<member name="M:ExtCore.Caching.LruCache`2.System-Collections-Generic-ICollection`1-Add(System.Collections.Generic.KeyValuePair{`0,`1})">
 <inherit />
</member>
<member name="T:ExtCore.Caching.LruCache`2">
 <summary>An immutable cache data structure with a Least-Recently-Used (LRU) eviction policy.</summary>
 <typeparam name="Key">The type of key used by the cache.</typeparam>
 <typeparam name="T">The type of the values stored in the cache.</typeparam>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.MapPartition``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``2,``3}}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Splits the cache into two caches by applying the given partitioning function
 to each binding in the cache.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Splits the cache into two caches containing the bindings for which the given
 predicate returns true and false, respectively.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Builds a new cache whose values are the results of applying the given function
 to each key-value pair in the cache. The key passed to the function indicates
 the key of the element being transformed.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},ExtCore.Caching.LruCache{``0,``1},``2)">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 newest (most-recently-used) to oldest (least-recently-used), threading an
 accumulator value through the computation.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,ExtCore.Caching.LruCache{``1,``2})">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 oldest (least-recently-used) to newest (most-recently-used), threading an
 accumulator value through the computation.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.IterateBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 newest (most-recently-used) to oldest (least-recently-used).
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Apply a function to each key-value pair in the cache, in order from
 oldest (least-recently-used) to newest (most-recently-used).
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.Caching.LruCache{``0,``1})">
 <summary>
 Applies the given function to each binding in the map.
 Returns the map comprised of the results "x" for each binding
 where the function returns <c>Some(x)</c>.
 </summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Caching.LruCache{``0,``1})">
 <summary>
 Builds a new map containing only the bindings for which the given
 predicate returns &quot;true&quot;.
 </summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Determines if all bindings in the map match the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Determines if any binding in the map matches the specified predicate.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Searches the cache looking for the least-recently-used element where the given function
 returns a Some value. If no such element is found, KeyNotFoundException is raised.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Searches the cache looking for the least-recently-used element where the given function
 returns a Some value. If no such element is found, returns None.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Create``2(System.UInt32)">
<summary>
 Create a new LruCache with the specified capacity.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.IsEmpty``2(ExtCore.Caching.LruCache{``0,``1})">
<summary>
 Is the cache empty?
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Capacity``2(ExtCore.Caching.LruCache{``0,``1})">
<summary>
 The maximum number of elements which could be stored in the cache.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Count``2(ExtCore.Caching.LruCache{``0,``1})">
<summary>
 The number of elements stored in the cache.
</summary>
</member>
<member name="M:ExtCore.Caching.LruCacheModule.Empty``2">
<summary>
 The empty cache.
</summary>
</member>
<member name="M:ExtCore.NativeInterop.NativePtr.IsNull``1(``0*)">
<summary>
 Determines if a pointer is null.
</summary>
</member>
<member name="M:ExtCore.NativeInterop.NativePtr.Zero``1">
<summary>
 The null pointer.
</summary>
</member>
<member name="T:ExtCore.NativeInterop.NativePtr">
<summary>
 Functions for working with native pointers.
</summary>
</member>
<member name="M:ExtCore.IO.IOExtensions.Stream.AsyncWriteSeq(System.IO.Stream,Microsoft.FSharp.Control.FSharpAsync{ExtCore.Collections.AsyncSeqItem{System.Byte[]}})">
<summary>
 Asynchronously writes all data specified by the 
 given asynchronous sequence to the stream.
</summary>
</member>
<member name="M:ExtCore.IO.IOExtensions.Stream.AsyncReadSeq(System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Asynchronously reads the stream in chunks of a specified size
 and returns the result as an asynchronous sequence.
</summary>
</member>
<member name="T:ExtCore.IO.IOExtensions">
<summary>
 Extensions that simplify working with Stream using async sequences.
</summary>
</member>
<member name="T:ExtCore.IO.File">
<summary>
 Functions operating on or over files.
</summary>
</member>
<member name="M:ExtCore.Net.HttpExtensions.HttpListenerResponse.AsyncReply(System.Net.HttpListenerResponse,System.String,System.Byte[])">
<summary>
 Sends the specified data as a reply with the specified content type
</summary>
</member>
<member name="M:ExtCore.Net.HttpExtensions.HttpListenerResponse.AsyncReply(System.Net.HttpListenerResponse,System.String)">
<summary>
 Sends the specified string as a reply in UTF-8 encoding
</summary>
</member>
<member name="M:ExtCore.Net.HttpExtensions.HttpListenerRequest.get_AsyncInputString(System.Net.HttpListenerRequest)">
<summary>
 Asynchronously reads the &apos;InputStream&apos; of the request and converts it to a string
</summary>
</member>
<member name="M:ExtCore.Net.HttpExtensions.HttpListener.Start.Static(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Net.HttpListenerRequest,System.Net.HttpListenerResponse},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Starts HttpListener on the specified URL. The &apos;handler&apos; function is
 called (in a new thread pool thread) each time an HTTP request is received.
</summary>
</member>
<member name="M:ExtCore.Net.HttpExtensions.HttpListener.AsyncGetContext(System.Net.HttpListener)">
<summary>
 Asynchronously waits for an incoming request and returns it.
</summary>
</member>
<member name="T:ExtCore.Net.HttpExtensions">
<summary>
 Extensions that simplify working with HttpListener and related types.
</summary>
</member>
<member name="M:ExtCore.Args.ArgParser.Usage(ExtCore.Args.ArgInfo[],Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Prints the help for each argument.
</summary>
</member>
<member name="M:ExtCore.Args.ArgParser.ParsePartial(Microsoft.FSharp.Core.FSharpRef{System.Int32},System.String[],Microsoft.FSharp.Collections.FSharpList{ExtCore.Args.ArgInfo},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Parse some of the arguments given by &apos;argv&apos;, starting at the given position.
</summary>
</member>
<member name="M:ExtCore.Args.ArgParser.Parse(ExtCore.Args.ArgInfo[],Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Parse the arguments given by System.Environment.GetEnvironmentVariables()
 according to the argument processing specifications &quot;specs&quot;.
 Args begin with &quot;-&quot;. Non-arguments are passed to &quot;f&quot; in
 order.  &quot;use&quot; is printed as part of the usage line if an error occurs.
</summary>
</member>
<member name="P:ExtCore.Args.ArgInfo.HelpText">
<summary>
 The usage help associated with the argument.
</summary>
</member>
<member name="P:ExtCore.Args.ArgInfo.Type">
<summary>
 The argument type and action of the argument.
</summary>
</member>
<member name="P:ExtCore.Args.ArgInfo.Name">
<summary>
 The name of the argument.
</summary>
</member>
<member name="M:ExtCore.Args.ArgInfo.Create(System.String,ExtCore.Args.ArgType,System.String)">
<summary>
 Create an ArgInfo instance.
</summary>
</member>
<member name="T:ExtCore.Args.ArgType">
<summary>
 The spec value describes the action of the argument,
 and whether it expects a following parameter.
</summary>
</member>
<member name="T:ExtCore.Args.ShowText">
<summary>
 When thrown, the string will be displayed to the user (usually printed to the console).
</summary>
</member>
<member name="P:ExtCore.ExtraTopLevelOperators.LazyListBuilder">
<summary>
 Computation expression (&quot;workflow&quot;) builder for creating lazy lists.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateHashSet``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a set from a sequence of elements.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateHashMap``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Builds a map from a sequence of key-value pairs.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateLongSet(System.Collections.Generic.IEnumerable{System.Int64})">
<summary>
 Builds a set from a sequence of elements.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateLongMap``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int64,``0}})">
<summary>
 Builds a map from a sequence of key-value pairs.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateIntSet(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 Builds a set from a sequence of elements.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateIntMap``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
 Builds a map from a sequence of key-value pairs.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateVector``1(``0[])">
<summary>
 Creates an immutable vector from an array.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.CreateMap``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Builds a map from a sequence of key-value pairs.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.UntagLong``1(System.Int64)">
<summary>
 Removes the tag from a tagged 64-bit integer, returning the 64-bit integer value.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.TagLong``1(System.Int64)">
<summary>
 Creates a tagged 64-bit integer from a 64-bit integer value.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.Untag``1(System.Int32)">
<summary>
 Removes the tag from a tagged integer, returning the integer value.
</summary>
</member>
<member name="M:ExtCore.ExtraTopLevelOperators.Tag``1(System.Int32)">
<summary>
 Creates a tagged integer from an integer value.
</summary>
</member>
<member name="T:ExtCore.ExtraTopLevelOperators">
<summary>
 Additional F# operators and types that are available without opening a module or namespace.
</summary>
</member>
</members>
</doc>
